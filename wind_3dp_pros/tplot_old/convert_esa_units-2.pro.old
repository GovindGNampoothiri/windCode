;+
;*****************************************************************************************
;
;  PROCEDURE:   convert_esa_units.pro
;  PURPOSE  :   Converts the units of an array of Wind 3DP EESA or PESA Low data
;                 structures.  The data associated with data.DATA is rescaled to the new
;                 units and data.UNITS_NAME is changed to the appropriate units.
;
;  CALLED BY:   
;               conv_units.pro
;
;  INCLUDES:
;               NA
;
;  CALLS:
;               convert_flux_units.pro
;               
;
;  REQUIRES:    
;               1)  THEMIS SPEDAS IDL libraries or UMN Modified Wind/3DP IDL Libraries
;
;  INPUT:
;               DATA      :  [N]-element array of Wind 3DP EESA or PESA Low IDL data
;                              structures containing the associated particle velocity
;                              distributions
;                              [e.g., see get_?.pro, ? = el, elb, pl, plb, eh, or ehb]
;               UNITS     :  Scalar [string] defining to which the units to
;                              convert.  The following inputs are allowed:
;                                'counts'      ;  # of counts
;                                'rate'        ;  raw count rate
;                                                 [# s^(-1)]
;                                'crate'       ;  scaled count rate
;                                                 [# s^(-1)]
;                                'flux'        ;  number flux (or intensity or fluence)
;                                                 [# cm^(-2) s^(-1) sr^(-1) eV^(-1)]
;                                'eflux'       ;  energy flux
;                                                 [eV cm^(-2) s^(-1) sr^(-1) eV^(-1)]
;                                'df'          ;  phase space density
;                                                 [# cm^(-3) km^(3) s^(-3)]
;
;  EXAMPLES:    
;               [calling sequence]
;               convert_esa_units, data, units [,SCALE=scale]
;
;  KEYWORDS:    
;               SCALE     :  Set to a named variable to return the conversion factor
;                              array used to scale the data
;
;   CHANGED:  1)  Davin Larson changed something...
;                                                                   [??/??/????   v1.0.?]
;             2)  Re-wrote and cleaned up
;                                                                   [06/22/2009   v1.1.0]
;             3)  Added error handling for unit conversion to E2FLUX or E3FLUX etc.
;                   which is not handled by convert_flux_units.pro
;                                                                   [07/30/2009   v1.1.1]
;             4)  Updated 'man' page
;                   and fixed syntax issue if data is an array of structures
;                                                                   [09/19/2009   v1.2.0]
;             5)  Updated 'man' page, cleaned up routine, added more error handling
;                   and now calls test_3dp_struc_format.pro and struct_value.pro
;                   *** Unit conversions now done in double precision ***
;                                                                   [02/19/2016   v1.3.0]
;
;   NOTES:      
;               1)  See also:  thm_convert_esa_units_lbwiii.pro
;               2)  As of version 1.3.0
;                     *** Unit conversions now done in double precision ***
;                     This prevents rounding errors causing quantization artifacts
;
;  REFERENCES:  
;               1)  Carlson et al., (1983), "An instrument for rapidly measuring
;                      plasma distribution functions with high resolution,"
;                      Adv. Space Res. Vol. 2, pp. 67-70.
;               2)  Curtis et al., (1989), "On-board data analysis techniques for
;                      space plasma particle instruments," Rev. Sci. Inst. Vol. 60,
;                      pp. 372.
;               3)  Lin et al., (1995), "A Three-Dimensional Plasma and Energetic
;                      particle investigation for the Wind spacecraft," Space Sci. Rev.
;                      Vol. 71, pp. 125.
;               4)  Paschmann, G. and P.W. Daly (1998), "Analysis Methods for Multi-
;                      Spacecraft Data," ISSI Scientific Report, Noordwijk, 
;                      The Netherlands., Int. Space Sci. Inst.
;               5)  McFadden, J.P., C.W. Carlson, D. Larson, M. Ludlam, R. Abiad,
;                      B. Elliot, P. Turin, M. Marckwordt, and V. Angelopoulos
;                      "The THEMIS ESA Plasma Instrument and In-flight Calibration,"
;                      Space Sci. Rev. 141, pp. 277-302, (2008).
;               6)  McFadden, J.P., C.W. Carlson, D. Larson, J.W. Bonnell,
;                      F.S. Mozer, V. Angelopoulos, K.-H. Glassmeier, U. Auster
;                      "THEMIS ESA First Science Results and Performance Issues,"
;                      Space Sci. Rev. 141, pp. 477-508, (2008).
;               7)  Auster, H.U., K.-H. Glassmeier, W. Magnes, O. Aydogar, W. Baumjohann,
;                      D. Constantinescu, D. Fischer, K.H. Fornacon, E. Georgescu,
;                      P. Harvey, O. Hillenmaier, R. Kroth, M. Ludlam, Y. Narita,
;                      R. Nakamura, K. Okrafka, F. Plaschke, I. Richter, H. Schwarzl,
;                      B. Stoll, A. Valavanoglou, and M. Wiedemann "The THEMIS Fluxgate
;                      Magnetometer," Space Sci. Rev. 141, pp. 235-264, (2008).
;               8)  Angelopoulos, V. "The THEMIS Mission," Space Sci. Rev. 141,
;                      pp. 5-34, (2008).
;               9)  Bordoni, F. "Channel electron multiplier efficiency for 10-1000 eV
;                      electrons," Nucl. Inst. & Meth. 97, pp. 405, (1971).
;              10)  Goruganthu, R.R. and W.G. Wilson "Relative electron detection
;                      efficiency of microchannel plates from 0-3 keV,"
;                      Rev. Sci. Inst. 55, pp. 2030-2033, (1984).
;              11)  Meeks, C. and P.B. Siegel "Dead time correction via the time series,"
;                      Amer. J. Phys. 76, pp. 589-590, (2008).
;              12)  Schecker, J.A., M.M. Schauer, K. Holzscheiter, and M.H. Holzscheiter
;                      "The performance of a microchannel plate at cryogenic temperatures
;                      and in high magnetic fields, and the detection efficiency for
;                      low energy positive hydrogen ions,"
;                      Nucl. Inst. & Meth. in Phys. Res. A 320, pp. 556-561, (1992).
;
;   CREATED:  ??/??/????
;   CREATED BY:  Davin Larson
;    LAST MODIFIED:  02/19/2016   v1.3.0
;    MODIFIED BY: Lynn B. Wilson III
;
;*****************************************************************************************
;-

PRO convert_esa_units, data, units, SCALE=scale

;;----------------------------------------------------------------------------------------
;;  Define some constants and dummy variables
;;----------------------------------------------------------------------------------------
fedf_names     = ['FLUX','EFLUX','DF']
crse2e3_names  = ['COUNTS','RATE','CRATE','E2FLUX','E3FLUX']
;;  so scale gets passed back even if units = data.units_name
scale          = 1e0
;;  Define dummy messages
notstr_mssg    = 'Must be an IDL structure...'
badstr_wind3dp = 'Not an appropriate Wind 3DP structure...'
notstring_msg  = 'UNITS must be a scalar string...'
;;----------------------------------------------------------------------------------------
;;  Check input
;;----------------------------------------------------------------------------------------
IF (N_PARAMS() LT 2) THEN RETURN       ;;  Quit if nothing was entered
str            = data[0]               ;;  in case it is an array of structures of the same format
IF (SIZE(str,/TYPE) NE 8) THEN BEGIN
  MESSAGE,notstr_mssg[0],/INFORMATIONAL,/CONTINUE
  RETURN
ENDIF
;;  Check to make sure input is a Wind 3DP structure
test           = (test_3dp_struc_format(str) NE 1)
IF (test[0]) THEN RETURN
;;  Check to make sure input is a string
IF (SIZE(units,/TYPE) NE 7) THEN BEGIN
  MESSAGE,notstring_msg[0],/INFORMATIONAL,/CONTINUE
  RETURN
ENDIF
;;  Check to make sure user is actually changing units
old_unit       = data[0].UNITS_NAME
new_unit       = units[0]
IF (STRUPCASE(new_unit[0]) EQ STRUPCASE(old_unit[0])) THEN RETURN
;;----------------------------------------------------------------------------------------
;;  Check if user is going from a flux-like to a "non-flux-like"(?) unit
;;----------------------------------------------------------------------------------------
fluxindx       = WHERE(fedf_names EQ STRUPCASE(old_unit[0]),fluxcnt)
efluxinx       = WHERE(crse2e3_names EQ STRUPCASE(new_unit[0]),eflxcnt)
;fluxindx = WHERE(['FLUX','EFLUX','DF'] EQ STRUPCASE(data[0].UNITS_NAME),fluxcnt)
;efluxinx = WHERE(['COUNTS','RATE','CRATE','E2FLUX','E3FLUX'] EQ STRUPCASE(units),eflxcnt)
;IF (fluxcnt GT 0L AND eflxcnt EQ 0L) THEN BEGIN
test           = (fluxcnt[0] GT 0L) AND (eflxcnt[0] EQ 0L)
IF (test[0]) THEN BEGIN
  ;;  Convert units using convert_flux_units.pro
  convert_flux_units,data,units,SCALE=scale
  RETURN
ENDIF
;;----------------------------------------------------------------------------------------
;;  These are vectorized for array of data structures
;;----------------------------------------------------------------------------------------
n_e            = data[0].NENERGY            ;;  # of energy bins
nbins          = data[0].NBINS              ;;  # of angle bins
n_str          = N_ELEMENTS(data)           ;;  # of data structures
energy         = DOUBLE(data.ENERGY)        ;;  [n_e,nbins,n_str]-Element array of energies [eV]
dt             = DOUBLE(data.DT)            ;;  " " integration/accumulation time [s]
deadtime       = DOUBLE(data.DEADTIME)      ;;  " " deadtimes [s]
rate           = DOUBLE(data.DATA)/dt       ;;  " " raw count rates [# s^(-1)]
dtc            = (1d0 - rate*deadtime)      ;;  " " scaled count rates [# s^(-1)]
;;  Remove bins with low corrected count rates
w              = WHERE(dtc LT 2d-1,c)
IF (c[0] GT 0) THEN dtc[w] = !VALUES.F_NAN
;;  Define the total geometry factor of the detector [cm^(+2) sr]
gf_facs        = DBLARR(n_e,nbins,n_str)    ;;  " " optical geometric factors [cm^(+2) sr]
FOR j=0L, n_str - 1L DO gf_facs[*,*,j] = DOUBLE(data[j].GEOM_FACTOR[0])
gf             = DOUBLE(data.GF)*gf_facs    ;;  " " scaled geometry factors [cm^(+2) sr]
;;----------------------------------------------------------------------------------------
;;  Define scale factors to new units
;;----------------------------------------------------------------------------------------
CASE STRUPCASE(new_unit[0]) OF
  'COUNTS' :  sfact = 1d0
  'RATE'   :  sfact = 1d0 / dt
  'CRATE'  :  sfact = 1d0 / (dtc * dt)
  'EFLUX'  :  sfact = 1d0 / (dtc * (dt * gf))
  'E2FLUX' :  sfact = 1d0 / (dtc * (dt * gf)) * energy
  'E3FLUX' :  sfact = 1d0 / (dtc * (dt * gf)) * energy^2d0
  'FLUX'   :  sfact = 1d0 / (dtc * (dt * gf * energy))
  'DF'     :  sfact = 1d0 / (dtc * (dt * gf * energy^2d0 * (2d5/mass^2d0) ))
  ELSE: BEGIN
    MESSAGE,'Undefined units: ',units[0]
    RETURN
  END
ENDCASE
;;  Adjust SCALE by factor associated with new units
scale         *= sfact
;;----------------------------------------------------------------------------------------
;;  Define scale factors of units to convert from
;;----------------------------------------------------------------------------------------
CASE STRUPCASE(old_unit[0]) OF
;CASE STRUPCASE(data[0].UNITS_NAME) OF
  'COUNTS' :  sfact = 1d0
  'RATE'   :  sfact = dt
  'CRATE'  :  sfact = (dtc * dt)
  'EFLUX'  :  sfact = (dtc * (dt * gf))
  'FLUX'   :  sfact = (dtc * (dt * gf * energy))
  'DF'     :  sfact = (dtc * (dt * gf * energy^2 * 2e5/mass^2))
  ELSE: BEGIN
    PRINT,'Unknown starting units: ',data[0].UNITS_NAME[0]
    RETURN
  END
ENDCASE
;;  Adjust SCALE by factor associated with input units
scale1         = scale*sfact
;;----------------------------------------------------------------------------------------
;;  Scale to new units
;;----------------------------------------------------------------------------------------
data.UNITS_NAME = units[0]
ddata0         = struct_value(data[0],'ddata',INDEX=index)
IF (index[0] GE 0) THEN data.DDATA = FLOAT(scale1 * ddata0)
temp           = DOUBLE(data.DATA)
data.DATA      = FLOAT(scale1 * temp)
scale          = FLOAT(scale1)
;;----------------------------------------------------------------------------------------
;;  Return to user
;;----------------------------------------------------------------------------------------

RETURN
END

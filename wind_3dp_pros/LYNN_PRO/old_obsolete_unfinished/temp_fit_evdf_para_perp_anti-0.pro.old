;*****************************************************************************************
;
;  FUNCTION :   temp_init_evdf_limits_str.pro
;  PURPOSE  :   This routine initializes the LIMITS structure and formats the data to
;                 be fitted in the wrapping routines.
;
;  CALLED BY:   
;               temp_fit_evdf_para_perp_anti.pro
;
;  CALLS:
;               test_wind_vs_themis_esa_struct.pro
;               dat_3dp_str_names.pro
;               dat_themis_esa_str_names.pro
;               str_element.pro
;               time_range_define.pro
;               wind_3dp_units.pro
;               trange_str.pro
;               conv_units.pro
;               spec3d.pro
;               log10_tickmarks.pro
;
;  REQUIRES:    
;               1)  THEMIS TDAS IDL libraries or UMN Modified Wind/3DP IDL Libraries
;
;  INPUT:
;               DATA       :  Scalar [structure] associated with a known THEMIS ESA
;                               data structure [see get_th?_peib.pro, ? = a-f]
;                               or a Wind/3DP data structure
;                               [see get_?.pro, ? = el, elb, pl, ph, eh, etc.]
;
;  EXAMPLES:    
;               temp = temp_init_evdf_limits_str(data,_EXTRA=ex_str)
;
;  KEYWORDS:    
;               LIMITS     :  Scalar [structure] that may contain any combination of the
;                               following structure tags or keywords accepted by
;                               PLOT.PRO:
;                                 XLOG,   YLOG,   ZLOG,
;                                 XRANGE, YRANGE, ZRANGE,
;                                 XTITLE, YTITLE,
;                                 TITLE, POSITION, REGION, etc.
;                                 (see IDL documentation for a description)
;
;   CHANGED:  1)  NA [MM/DD/YYYY   v1.0.0]
;
;   NOTES:      
;               1)  User should not call this routine directly
;
;  REFERENCES:  
;               
;
;   CREATED:  09/13/2014
;   CREATED BY:  Lynn B. Wilson III
;    LAST MODIFIED:  09/13/2014   v1.0.0
;    MODIFIED BY: Lynn B. Wilson III
;
;*****************************************************************************************

FUNCTION temp_init_evdf_limits_str,data,_EXTRA=ex_str

;;----------------------------------------------------------------------------------------
;;  Define some constants and dummy variables
;;----------------------------------------------------------------------------------------
f              = !VALUES.F_NAN
d              = !VALUES.D_NAN
;;  Dummy error messages
noinpt_msg     = 'User must supply an a velocity distribution function as an IDL structure...'
nofind_msg     = 'No finite data for this VDF...'
notstr_msg     = 'Must be an IDL structure...'
notvdf_msg     = 'Input must be a velocity distribution function as an IDL structure...'
badvdf_msg     = 'Input must be an IDL structure with similar format to Wind/3DP or THEMIS/ESA...'
not3dp_msg     = 'Input must be a velocity distribution IDL structure from Wind/3DP...'
notthm_msg     = 'Input must be a velocity distribution IDL structure from THEMIS/ESA...'
;;----------------------------------------------------------------------------------------
;;  Check input
;;----------------------------------------------------------------------------------------
IF (N_PARAMS() LT 1) THEN BEGIN
  MESSAGE,noinpt_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
IF (SIZE(data,/TYPE) NE 8L) THEN BEGIN
  MESSAGE,notstr_mssg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
dat            = data[0]
;;  Check to make sure distribution has the correct format
test0          = test_wind_vs_themis_esa_struct(dat[0],/NOM)
test           = (test0.(0) + test0.(1)) NE 1
IF (test[0]) THEN BEGIN
  MESSAGE,notvdf_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
;;  Define number of solid-angle and energy bins
dat0           = dat[0]
;nb             = dat0[0].NBINS
nnd            = dat0[0].NBINS[0]
nne            = dat0[0].NENERGY[0]
;;  Determine instrument (i.e., ESA or 3DP) and define electric charge
IF (test0.(0)) THEN BEGIN
  ;;  Wind
  mission = 'Wind'
  strns   = dat_3dp_str_names(dat0[0])
  IF (SIZE(strns,/TYPE) NE 8) THEN BEGIN
    ;;  Neither Wind/3DP nor THEMIS/ESA VDF
    MESSAGE,not3dp_msg[0],/INFORMATIONAL,/CONTINUE
    RETURN,0b
  ENDIF ELSE inst_nm_mode = strns.LC[0]         ;;  e.g., 'Pesa Low Burst'
ENDIF ELSE BEGIN
  IF (test0.(1)) THEN BEGIN
    ;;  THEMIS
    mission = 'THEMIS'
    strns   = dat_themis_esa_str_names(dat0[0])
    IF (SIZE(strns,/TYPE) NE 8) THEN BEGIN
      ;;  Neither Wind/3DP nor THEMIS/ESA VDF
      MESSAGE,notthm_msg[0],/INFORMATIONAL,/CONTINUE
      RETURN,0b
    ENDIF ELSE BEGIN
      temp         = strns.LC[0]                  ;;  e.g., 'IESA 3D Reduced Distribution'
      tposi        = STRPOS(temp[0],'Distribution') - 1L
      inst_nm_mode = STRMID(temp[0],0L,tposi[0])  ;;  e.g., 'IESA 3D Reduced'
    ENDELSE
  ENDIF ELSE BEGIN
    ;;  Other mission?
    str_element,dat0,'DATA_NAME',inst_nm_mode
    str_element,dat0,'PROJECT_NAME',mission
    IF (N_ELEMENTS(inst_nm_mode) EQ 0) THEN BEGIN
      MESSAGE,badvdf_msg[0],/INFORMATIONAL,/CONTINUE
      RETURN,0b
    ENDIF
  ENDELSE
ENDELSE
;;  Define plot title prefix
test           = (N_ELEMENTS(mission) EQ 0)
IF (test[0]) THEN ttl_pref = inst_nm_mode[0] ELSE ttl_pref = mission[0]+' '+inst_nm_mode[0]
;;----------------------------------------------------------------------------------------
;;  Set up plot specific parameters
;;----------------------------------------------------------------------------------------
;;  Define time range and date of eVDF
tr_vdf         = [dat0[0].TIME,dat0[0].END_TIME]
time_ra        = time_range_define(TRANGE=tr_vdf)
tra            = time_ra.TR_UNIX
tdate          = time_ra.TDATE_SE  ;  e.g. '2009-07-13'
;;  Define desired units strings for plot titles
units          = 'flux'                     ;;  i.e., # cm^(-2) s^(-1) sr^(-1) eV^(-1)
new_units      = wind_3dp_units(units[0])
gunits         = new_units.G_UNIT_NAME      ;;  e.g., 'flux'
punits         = new_units.G_UNIT_P_NAME    ;;  e.g., ' (# cm!U-2!Ns!U-1!Nsr!U-1!NeV!U-1!N)'
ytitle         = gunits[0]+punits[0]
title          = '('+ttl_pref[0]+')'+' '+trange_str(tra[0],tra[1])
xtitle         = 'Energy [eV]'
;;  Check for input plot limits structure
IF (SIZE(ex_str,/TYPE) NE 8) THEN BEGIN
  ;;  Nothing set, so set up default limits structure
  str_element,limits,'XSTYLE',1,/ADD_REPLACE
  str_element,limits,'YSTYLE',1,/ADD_REPLACE
  str_element,limits,'CHARSIZE',1.2,/ADD_REPLACE
  str_element,limits,'XMARGIN',[10,10],/ADD_REPLACE
ENDIF ELSE BEGIN
  ;;  Structure set, check for LIMITS structure inside
  str_element,ex_str,'LIMITS',limits
  IF (SIZE(limits,/TYPE) NE 8) THEN BEGIN
    ;;  Nothing set, so set up default limits structure
    str_element,limits,'XSTYLE',1,/ADD_REPLACE
    str_element,limits,'YSTYLE',1,/ADD_REPLACE
    str_element,limits,'CHARSIZE',1.2,/ADD_REPLACE
    str_element,limits,'XMARGIN',[10,10],/ADD_REPLACE
  ENDIF ELSE BEGIN
    ;;  Check for appropriate structure tags
    str_element,limits,  'XSTYLE',xstyle
    str_element,limits,  'YSTYLE',ystyle
    str_element,limits,'CHARSIZE',charsize
    str_element,limits, 'XMARGIN',xmargin
    test = (N_ELEMENTS(xstyle) EQ 0)
    IF (test[0]) THEN str_element,limits,  'XSTYLE',1,/ADD_REPLACE
    test = (N_ELEMENTS(ystyle) EQ 0)
    IF (test[0]) THEN str_element,limits,  'YSTYLE',1,/ADD_REPLACE
    test = (N_ELEMENTS(charsize) EQ 0)
    IF (test[0]) THEN str_element,limits,'CHARSIZE',1.2,/ADD_REPLACE
    test = (N_ELEMENTS(xmargin) EQ 0)
    IF (test[0]) THEN str_element,limits, 'XMARGIN',[10,10],/ADD_REPLACE
  ENDELSE
ENDELSE
;;  Open windows
WINDOW,1,RETAIN=2,XSIZE=800,YSIZE=800,TITLE=ttl_pref[0]+' Plots ['+tdate[0]+']'
WINDOW,2,RETAIN=2,XSIZE=800,YSIZE=800,TITLE=ttl_pref[0]+' Plots ['+tdate[0]+']'
WINDOW,3,RETAIN=2,XSIZE=800,YSIZE=800,TITLE=ttl_pref[0]+' Plots ['+tdate[0]+']'
;;----------------------------------------------------------------------------------------
;;  Plot initial distribution spectra with colors indicating pitch-angles
;;----------------------------------------------------------------------------------------
units          = 'flux'
;;  Calculate the one-count levels for error estimates
dat1c          = dat0[0]
dat2f          = conv_units(dat0[0],units[0],/FRACTIONAL_COUNTS)
dat1c[0].DATA  = 1e0
dat1c          = conv_units(dat1c[0],units[0],/FRACTIONAL_COUNTS)
onec0          = dat1c[0].DATA
;;  Plot all bins
pang           = 1
WSET,1
WSHOW,1
spec3d,dat0[0],UNITS=units,XDAT=energy0,YDAT=data0,LIMITS=limits,/RM_PHOTO_E,$
               PITCHANGLE=pang,/LABEL,COLOR=pa_cols
;;----------------------------------------------------------------------------------------
;;  First make sure results are consistent
;;----------------------------------------------------------------------------------------
sze0           = SIZE(energy0,/DIMENSIONS)
szd0           = SIZE(data0,/DIMENSIONS)
szp0           = SIZE(pang,/DIMENSIONS)
test           = (sze0[0] NE nne[0]) OR (sze0[1] NE nnd[0]) OR $
                 (szd0[0] NE nne[0]) OR (szd0[1] NE nnd[0]) OR $
                 (szp0[0] NE nnd[0])
IF (test[0]) THEN BEGIN
  MESSAGE,nofind_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
;;----------------------------------------------------------------------------------------
;;  Second, add titles and log-scale settings to LIMITS
;;----------------------------------------------------------------------------------------
str_element,limits,'XTITLE',xtitle[0],/ADD_REPLACE
str_element,limits,'YTITLE',ytitle[0],/ADD_REPLACE
str_element,limits, 'TITLE', title[0],/ADD_REPLACE
str_element,limits,  'XLOG',        1,/ADD_REPLACE
str_element,limits,  'YLOG',        1,/ADD_REPLACE
;;----------------------------------------------------------------------------------------
;;  Third, define plot ranges (if not already done in LIMITS structure)
;;----------------------------------------------------------------------------------------
test           = (data0 GT 0) AND FINITE(data0)
good           = WHERE(test,gd)
IF (gd[0] EQ 0) THEN BEGIN
  MESSAGE,nofind_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
e_mnmx         = [MIN(energy0[good],/NAN),MAX(energy0[good],/NAN)]*[9d-1,11d-1]
d_mnmx         = [MIN(data0[good],/NAN),MAX(data0[good],/NAN)]*[9d-1,11d-1]
str_element,limits,'XRANGE',xran
str_element,limits,'YRANGE',yran
IF (N_ELEMENTS(xran) EQ 0) THEN BEGIN
  xran = e_mnmx
  str_element,limits,'XRANGE',xran,/ADD_REPLACE
ENDIF
IF (N_ELEMENTS(yran) EQ 0) THEN BEGIN
  yran = d_mnmx
  str_element,limits,'YRANGE',yran,/ADD_REPLACE
ENDIF
;;----------------------------------------------------------------------------------------
;;  Fourth, define plot tick marks (if not already done in LIMITS structure)
;;----------------------------------------------------------------------------------------
tagns          = STRLOWCASE(TAG_NAMES(limits))
pref_tag       = STRMID(tagns,0L,5L)
check_suffx    = ['tickv','tickname','ticks','range']
check_xtags    = 'x'+check_suffx
check_ytags    = 'y'+check_suffx
test_xyran     = [WHERE(tagns EQ check_xtags[3]),WHERE(tagns EQ check_ytags[3])]
test_xytic     = [WHERE(pref_tag EQ 'xtick'),WHERE(pref_tag EQ 'ytick')]
def_minmax     = [1d-30,1d30]
IF (test_xytic[0] LT 0) THEN BEGIN
  ;;  Define new tick marks for X-Axis
  IF (test_xyran[0] GE 0) THEN BEGIN
    xran  = limits.XRANGE
    rmnmx = xran
    force = 1
  ENDIF ELSE BEGIN
    rmnmx = def_minmax
    force = 0
  ENDELSE
  xtick_str = log10_tickmarks(energy0,RANGE=xran,MIN_VAL=rmnmx[0],MAX_VAL=rmnmx[1],FORCE_RA=force)
  IF (SIZE(xtick_str,/TYPE) EQ 8) THEN BEGIN
    str_element,limits,   'XTICKV',   xtick_str.TICKV,/ADD_REPLACE
    str_element,limits,'XTICKNAME',xtick_str.TICKNAME,/ADD_REPLACE
    str_element,limits,   'XTICKS',   xtick_str.TICKS,/ADD_REPLACE
    str_element,limits,   'XMINOR',                 9,/ADD_REPLACE
  ENDIF
ENDIF
IF (test_xytic[1] LT 0) THEN BEGIN
  ;;  Define new tick marks for Y-Axis
  IF (test_xyran[1] GE 0) THEN  BEGIN
    yran  = limits.YRANGE
    rmnmx = yran
    force = 1
  ENDIF ELSE BEGIN
    rmnmx = def_minmax
    force = 0
  ENDELSE
  ytick_str = log10_tickmarks(data0,RANGE=yran,MIN_VAL=rmnmx[0],MAX_VAL=rmnmx[1],FORCE_RA=force)
  IF (SIZE(ytick_str,/TYPE) EQ 8) THEN BEGIN
    str_element,limits,   'YTICKV',   ytick_str.TICKV,/ADD_REPLACE
    str_element,limits,'YTICKNAME',ytick_str.TICKNAME,/ADD_REPLACE
    str_element,limits,   'YTICKS',   ytick_str.TICKS,/ADD_REPLACE
    str_element,limits,   'YMINOR',                 9,/ADD_REPLACE
  ENDIF
ENDIF
;;----------------------------------------------------------------------------------------
;;  Define output structure
;;----------------------------------------------------------------------------------------
;;  Define original eVDF data structure in units of counts
str_element,struc,     'DATA',        dat0,/ADD_REPLACE
;;  Define one-count copy eVDF data structure
str_element,struc,   'DAT_1C',       dat1c,/ADD_REPLACE
;;  Define original eVDF data structure in units of flux
str_element,struc,   'DAT__F',       dat2f,/ADD_REPLACE
str_element,struc,   'LIMITS',      limits,/ADD_REPLACE
str_element,struc,   'P_ANGS',        pang,/ADD_REPLACE
str_element,struc,  'PA_COLS',     pa_cols,/ADD_REPLACE
str_element,struc,   'DATA_0',       data0,/ADD_REPLACE
str_element,struc, 'ENERGY_0',     energy0,/ADD_REPLACE
str_element,struc,   'ONE_C0',       onec0,/ADD_REPLACE
;;  Define extra outputs
str_element,struc,  'MISSION',     mission,/ADD_REPLACE
str_element,struc,'INST_MODE',inst_nm_mode,/ADD_REPLACE
str_element,struc,    'TDATE',    tdate[0],/ADD_REPLACE
;;----------------------------------------------------------------------------------------
;;  Return to user
;;----------------------------------------------------------------------------------------

RETURN,struc
END


;*****************************************************************************************
;
;  FUNCTION :   temp_fit_evdf_cut_wrapper.pro
;  PURPOSE  :   This is a wrapping routine for the actual fit function calling sequence.
;                 The model function is a combined power-law, exponential function of
;                 the form:
;
;                   Y = A X^(B) e^(C X) + D
;
;                 where the physical interpretation of the parameters are:
;
;                   Y  :  dJ/dE  = differential intensity
;                                  [# cm^(-2) s^(-1) sr^(-1) eV^(-1)]
;                   X  :   E     = particle kinetic energy
;                                  [eV]
;                   A  :   K     = Lim_{E --> 0} (dJ/dE)
;                                  [~10^(6) for electrons]
;                   B  :  -¥     = power-law slope or spectral index
;                                  [unitless]
;                   C  :  -1/E_o = inverse of e-folding energy
;                                  { where:  E_o ~ 100's of eV for electrons }
;                                  [eV^(-1)]
;                   D  :  dJdE_o = Lim_{E --> Infinity} (dJ/dE) ~ 0
;                                  { expect:  ~ 0 for reasonable particles }
;                                  [# cm^(-2) s^(-1) sr^(-1) eV^(-1)]
;
;  CALLED BY:   
;               temp_fit_evdf_para_perp_anti.pro
;
;  CALLS:
;               wrapper_multi_func_fit.pro
;
;  REQUIRES:    
;               1)  THEMIS TDAS IDL libraries or UMN Modified Wind/3DP IDL Libraries
;
;  INPUT:
;               ;;..................................................
;               ;;  Below, the following definitions apply:
;               ;;    T  =  # of solid angle bins in eVDF
;               ;;    S  =  # of energy bins in eVDF
;               ;;..................................................
;               DATA     :  [T,S]-Element array [float] containing the data [flux] to
;                             which the the model function should be fit
;               ENERGY   :  [T,S]-Element array [float] containing the energies [eV]
;                             associated with each element in DATA
;               PANG     :  [T]-Element array [float] defining the average pitch-angle
;                             of each solid angle bin in DATA
;               CUT_RAN  :  [2]-Element array [float] defining the range of angles
;                             between which to average the data and use to fit
;               PARAM    :  [4]-Element [float] array containing the following
;                             initialization quantities for the model function
;                             (see above):
;                               PARAM[0] = A
;                               PARAM[1] = B
;                               PARAM[2] = C
;                               PARAM[3] = D
;
;  EXAMPLES:    
;               test = temp_fit_evdf_cut_wrapper(data,energy,pang,cut_ran,param,_EXTRA=ex_str)
;
;  KEYWORDS:    
;               CUT_DIR  :  Scalar [float] defining the angle along which
;                             the fit is being performed
;                                          {  MIN(CUT_RAN)  for Parallel cut
;                               Default  = { MEAN(CUT_RAN)  for Perpendicular cut
;                                          {  MAX(CUT_RAN)  for Anti-parallel cut
;               E_LOW    :  Scalar [float] defining the lowest energy [eV] to consider
;                             for the data to send to the fit routines
;                             [Default = 30e0]
;               ONE_C    :  [T,S]-Element array [float] containing the one-count level
;                             for the eVDF from which DATA was derived [flux]
;
;   CHANGED:  1)  NA [MM/DD/YYYY   v1.0.0]
;
;   NOTES:      
;               
;
;  REFERENCES:  
;               
;
;   CREATED:  09/13/2014
;   CREATED BY:  Lynn B. Wilson III
;    LAST MODIFIED:  09/13/2014   v1.0.0
;    MODIFIED BY: Lynn B. Wilson III
;
;*****************************************************************************************

FUNCTION temp_fit_evdf_cut_wrapper,data0,energy0,pang0,cut_ran,param,_EXTRA=ex_str

;;----------------------------------------------------------------------------------------
;;  Define some constants and dummy variables
;;----------------------------------------------------------------------------------------
f              = !VALUES.F_NAN
d              = !VALUES.D_NAN
;;  Dummy error messages
noinpt_msg     = 'User must supply DATA, ENERGY, PANG, CUT_RAN, and PARAM...'
nofind_msg     = 'Incorrect input format...'
;;----------------------------------------------------------------------------------------
;;  Check input
;;----------------------------------------------------------------------------------------
IF (N_PARAMS() LT 5) THEN BEGIN
  MESSAGE,noinpt_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
;;  Check formats
sze0           = SIZE(energy0,/DIMENSIONS)
szd0           = SIZE(data0,/DIMENSIONS)
szp0           = SIZE(pang0,/DIMENSIONS)
szc0           = SIZE(cut_ran,/DIMENSIONS)
szm0           = SIZE(param,/DIMENSIONS)
test           = (sze0[0] NE szd0[0]) OR (sze0[1] NE szd0[1]) OR $
                 (sze0[1] NE szp0[0]) OR (szd0[1] NE szp0[0]) OR $
                 (szc0[0] NE      2L) OR (szm0[0] NE      4L)
IF (test[0]) THEN BEGIN
  MESSAGE,nofind_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
;;----------------------------------------------------------------------------------------
;;  Define parameters
;;----------------------------------------------------------------------------------------
nne            = sze0[0]
nnd            = sze0[1]
;;  Sort by pitch-angle
sp             = SORT(pang0)
pang           = pang0[sp]
data_pa        = data0[*,sp]
ener_pa        = energy0[*,sp]
;;----------------------------------------------------------------------------------------
;;  Check keywords
;;----------------------------------------------------------------------------------------
;;  Check ONE_C
test           = (TOTAL(SIZE(one_c,/DIMENSIONS) EQ szd0) EQ 2)
IF (test[0])   THEN g_onec = 1 ELSE g_onec = 0
IF (g_onec[0]) THEN onec_pa = one_c[*,sp] ELSE onec_pa = REPLICATE(f,szd0[0],szd0[1])
;;  Check E_LOW
test           = (N_ELEMENTS(e_low) EQ 1)
IF (test[0]) THEN BEGIN
  IF (e_low[0] GE 0 AND FINITE(e_low[0])) THEN e_low = e_low[0] ELSE e_low = 30e0
ENDIF ELSE BEGIN
  e_low = 30e0
ENDELSE
;;  Check CUT_DIR
avg_cran       = MEAN(cut_ran,/NAN)
tests          = [(avg_cran[0] LT 45e0),                          $
                  (avg_cran[0] LT 135e0 AND avg_cran[0] GE 45e0), $
                  (avg_cran[0] GE 135e0)]
good           = WHERE(tests,gd)
CASE good[0] OF
  0 : def_cdir = MIN(cut_ran,/NAN)   ;;  Parallel fit
  1 : def_cdir = avg_cran[0]         ;;  Perpendicular fit
  2 : def_cdir = MAX(cut_ran,/NAN)   ;;  Anti-parallel fit
ENDCASE
test           = (N_ELEMENTS(cut_dir) EQ 1)
IF (test[0]) THEN BEGIN
  test = (cut_dir[0] LT cut_ran[0]) OR (cut_dir[0] GT cut_ran[1])
  IF (test[0]) THEN cut_dir = def_cdir[0]
ENDIF ELSE BEGIN
  ;;  CUT_DIR not supplied by user
  cut_dir = def_cdir[0]
ENDELSE
;;----------------------------------------------------------------------------------------
;;  Determine the elements that fall withing desired pitch-angle ranges
;;----------------------------------------------------------------------------------------
test_pang      = (pang GE cut_ran[0]) AND (pang LE cut_ran[1])
good_pang      = WHERE(test_pang,gd_pang,COMPLEMENT=bad_pang,NCOMPLEMENT=bd_pang)
;;----------------------------------------------------------------------------------------
;;  Fit to model function if data within constraints
;;----------------------------------------------------------------------------------------
IF (gd_pang GT 0) THEN BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Good values found --> try to fit
  ;;--------------------------------------------------------------------------------------
  ;;  Define the good data, energy, and pitch-angles
  data_pang      = data_pa[*,good_pang]
  ener_pang      = ener_pa[*,good_pang]
  pang_pang      = pang[good_pang]
  ;;  Average data over each direction
  Avgf_pang      = TOTAL(data_pang,2L,/NAN)/TOTAL(FINITE(data_pang),2L,/NAN)
  AvgE_pang      = TOTAL(ener_pang,2L,/NAN)/TOTAL(FINITE(ener_pang),2L,/NAN)
  IF (g_onec[0]) THEN BEGIN
    ;;  Find PA bin closest to CUT_DIR
    diff_pang      = MIN(ABS(cut_dir[0] - pang_pang),gind_pang,/NAN)
    onec_pang      = onec_pa[*,good_pang[gind_pang[0]]]
    Avg1_pang      = onec_pang
  ENDIF ELSE BEGIN
    diff_pang      = MIN(ABS(pang_pang),gind_pang,/NAN)
    onec_pang      = REPLICATE(f,nne[0])
    Avg1_pang      = 1e-2*Avgf_pang
  ENDELSE
  ;;--------------------------------------------------------------------------------------
  ;;  Try fitting to Y = A X^(B) e^(C X) + D
  ;;
  ;;    Y  =  dJ/dE [flux units]
  ;;    X  =  E  [eV]
  ;;    A  =  K  [some constant]
  ;;    B  =  -¥ = power-law slope = spectral index
  ;;    C  =  -1/E_o, E_o = e-folding energy [eV]
  ;;    D  =  (dJ/dE)_o = limit as E --> 0
  ;;--------------------------------------------------------------------------------------
  ;;  Use only those elements which satisfy the following two constraints:
  ;;    1)  E > 30 eV
  ;;    2)  f > f_1c    [f_1c = one-count level]
  e_low          = 30e0
  test_pang_fit  =  (AvgE_pang GE e_low[0]) AND $
                   ((Avgf_pang GE Avg1_pang) AND (Avgf_pang GT 0) AND FINITE(Avgf_pang))
  good_pang_fit  = WHERE(test_pang_fit,gd_pang_fit,COMPLEMENT=bad_pang_fit,NCOMPLEMENT=bd_pang_fit)
  IF (gd_pang_fit GT 0) THEN BEGIN
    x              = AvgE_pang[good_pang_fit]
    y              = Avgf_pang[good_pang_fit]
    yerr           = ABS(Avg1_pang[good_pang_fit])
    wghts          = 1d0/ABS(yerr)            ;;  Poisson weighting
    func           = 4                        ;;  i.e., Y = A X^(B) e^(C X) + D
    fit_str_pang   = wrapper_multi_func_fit(x,y,param,FIT_FUNC=func[0],ERROR=yerr,        $
                                            WEIGHTS=wghts,A_RANGE=a_range,B_RANGE=b_range,$
                                            C_RANGE=c_range,D_RANGE=d_range,TIED_P=tied_p,$
                                            FIXED_P=fixed_p,ITMAX=itmax,CTOL=ctol)
    IF (SIZE(fit_str_pang,/TYPE) NE 8L) THEN BEGIN
      x            = dumb10
      fit_str_pang = d_fit_struc
    ENDIF
  ENDIF ELSE BEGIN
    ;;  No finite data within constraints --> use dummy values
    x            = dumb10
    fit_str_pang = d_fit_struc
  ENDELSE
ENDIF ELSE BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Nothing within 20 degrees of 0 was found --> No parallel fit
  ;;--------------------------------------------------------------------------------------
  pang_pang      = dumb10
  diff_pang      = dumb10
  data_pang      = dumb10
  ener_pang      = dumb10
  onec_pang      = dumb10
  Avgf_pang      = dumb10
  AvgE_pang      = dumb10
  Avg1_pang      = dumb10
  x              = dumb10
  y              = dumb10
  fit_str_pang   = d_fit_struc
ENDELSE
;;----------------------------------------------------------------------------------------
;;  Define output structure
;;----------------------------------------------------------------------------------------
data_str       = {DATA_SORT:data_pa,DATA_PANG:data_pang,AVG_DATA:Avgf_pang,FIT_DATA:y}
ener_str       = {ENER_SORT:ener_pa,ENER_PANG:ener_pang,AVG_ENER:AvgE_pang,FIT_ENER:x}
onec_str       = {ONEC_SORT:onec_pa,ONEC_PANG:onec_pang,AVG_ONEC:Avg1_pang,FIT_ONEC:yerr}
struc          = {DATA:data_str,ENERGY:ener_str,ONE_C:onec_str,FIT:fit_str_pang}
;;----------------------------------------------------------------------------------------
;;  Return to user
;;----------------------------------------------------------------------------------------

RETURN,struc
END


;+
;*****************************************************************************************
;
;  FUNCTION :   temp_fit_evdf_para_perp_anti.pro
;  PURPOSE  :   This is a wrapping routine that takes an input velocity distribution
;                 function, in the form of an IDL structure, and then fits cuts of the
;                 data along the parallel, perpendicular, and anti-parallel directions
;                 to a combined power-law, exponential function of the form:
;
;                   Y = A X^(B) e^(C X) + D
;
;                 where the physical interpretation of the parameters are:
;
;                   Y  :  dJ/dE  = differential intensity
;                                  [# cm^(-2) s^(-1) sr^(-1) eV^(-1)]
;                   X  :   E     = particle kinetic energy
;                                  [eV]
;                   A  :   K     = Lim_{E --> 0} (dJ/dE)
;                                  [~10^(6) for electrons]
;                   B  :  -¥     = power-law slope or spectral index
;                                  [unitless]
;                   C  :  -1/E_o = inverse of e-folding energy
;                                  { where:  E_o ~ 100's of eV for electrons }
;                                  [eV^(-1)]
;                   D  :  dJdE_o = Lim_{E --> Infinity} (dJ/dE) ~ 0
;                                  { expect:  ~ 0 for reasonable particles }
;                                  [# cm^(-2) s^(-1) sr^(-1) eV^(-1)]
;
;  CALLED BY:   
;               
;
;  CALLS:
;               
;
;  REQUIRES:    
;               1)  THEMIS TDAS IDL libraries or UMN Modified Wind/3DP IDL Libraries
;
;  INPUT:
;               DATA       :  Scalar [structure] associated with a known THEMIS ESA
;                               data structure [see get_th?_peib.pro, ? = a-f]
;                               or a Wind/3DP data structure
;                               [see get_?.pro, ? = el, elb, pl, ph, eh, etc.]
;
;  EXAMPLES:    
;               temp = temp_fit_evdf_para_perp_anti(data,_EXTRA=ex_str)
;
;  KEYWORDS:    
;               LIMITS     :  Scalar [structure] that may contain any combination of the
;                               following structure tags or keywords accepted by
;                               PLOT.PRO:
;                                 XLOG,   YLOG,   ZLOG,
;                                 XRANGE, YRANGE, ZRANGE,
;                                 XTITLE, YTITLE,
;                                 TITLE, POSITION, REGION, etc.
;                                 (see IDL documentation for a description)
;               
;
;   CHANGED:  1)  NA [MM/DD/YYYY   v1.0.0]
;
;   NOTES:      
;               
;
;  REFERENCES:  
;               
;
;   CREATED:  09/13/2014
;   CREATED BY:  Lynn B. Wilson III
;    LAST MODIFIED:  09/13/2014   v1.0.0
;    MODIFIED BY: Lynn B. Wilson III
;
;*****************************************************************************************
;-

FUNCTION temp_fit_evdf_para_perp_anti,data,_EXTRA=ex_str

;;----------------------------------------------------------------------------------------
;;  Define some constants and dummy variables
;;----------------------------------------------------------------------------------------
f              = !VALUES.F_NAN
d              = !VALUES.D_NAN
struc          = 0
dumb0          = d
dumb2          = REPLICATE(d,2)
dumb4          = REPLICATE(d,4)
dumb10         = REPLICATE(d,10)
tags           = ['YFIT','FIT_RESULTS','SIG_PARAM','CHISQ','N_ITER','STATUS','YERROR','FUNC']
d_fit_struc    = CREATE_STRUCT(tags,dumb10,dumb4,dumb4,dumb0,-1,-1,dumb0,'')
;;  Dummy logic variables
parallel_fit   = 1
perpendi_fit   = 1
antipara_fit   = 1
;;  Dummy error messages
noinpt_msg     = 'User must supply an a velocity distribution function as an IDL structure...'
nofind_msg     = 'No finite data for this VDF...'
notstr_msg     = 'Must be an IDL structure...'
notvdf_msg     = 'Input must be a velocity distribution function as an IDL structure...'
badvdf_msg     = 'Input must be an IDL structure with similar format to Wind/3DP or THEMIS/ESA...'
not3dp_msg     = 'Input must be a velocity distribution IDL structure from Wind/3DP...'
notthm_msg     = 'Input must be a velocity distribution IDL structure from THEMIS/ESA...'
;;----------------------------------------------------------------------------------------
;;  Initialize data structure and LIMITS structure
;;----------------------------------------------------------------------------------------
STOP
init_struc     = temp_init_evdf_limits_str(data,_EXTRA=ex_str)
IF (SIZE(init_struc,/TYPE) NE 8L) THEN BEGIN
  RETURN,0b
ENDIF
;;  Define eVDF data structures
dat0           = init_struc.DATA
dat1c          = init_struc.DAT_1C
dat2f          = init_struc.DAT__F
onec0          = init_struc.ONE_C0
;;  Define LIMITS structure
limits         = init_struc.LIMITS
;;  Define outputs from spec3d.pro
pang0          = init_struc.P_ANGS        ;;  Pitch-angle bins [degrees]
pa_cols        = init_struc.PA_COLS
data0          = init_struc.DATA_0        ;;  Data sorted by pitch-angle bins [flux units]
energy0        = init_struc.ENERGY_0      ;;  Energies [eV] sorted by pitch-angle bins
;;  Define extra outputs
mission        = init_struc.MISSION
inst_nm_mode   = init_struc.INST_MODE
tdate          = init_struc.TDATE
para_ra        = [0d0,2d1]
anti_ra        = [16d1,18d1]
perp_ra        = [8d1,10d1]
;;----------------------------------------------------------------------------------------
;;  Parallel Fit
;;----------------------------------------------------------------------------------------
param          = DBLARR(4)
param[0]       = 1d6                      ;;  Lim_{E --> Infinity} (dJ/dE) ~ 10^(6)
param[1]       = -2d0                     ;;  ¥ ~ 2
param[2]       = -1d0/1d2                 ;;  E_o ~ 100 eV
param[3]       = 0d0                      ;;  Lim_{E --> Infinity} (dJ/dE)_o ~ 0
bran           = [1,1,-7d0,-5d-2]         ;;  Constrain spectral index
cran           = [1,1,-1d0/1d1,-1d0/1d4]  ;;  Constrain E_o
fixed_p        = REPLICATE(1b,4)
fixed_p[3]     = 0b
fit_str_para   = temp_fit_evdf_cut_wrapper(data0,energy0,pang0,para_ra,param,$
                                           CUT_DIR=0e0,E_LOW=30e0,ONE_C=onec0,$
                                           B_RANGE=bran,C_RANGE=cran,FIXED_P=fixed_p)
;;  Define parameters
data_para_str  = fit_str_para.DATA
ener_para_str  = fit_str_para.ENERGY
onec_para_str  = fit_str_para.ONE_C
fit__para_str  = fit_str_para.FIT
Avgf_para      = data_para_str.AVG_DATA
AvgE_para      = ener_para_str.AVG_ENER
Avg1_para      = onec_para_str.AVG_ONEC

;;  Define fit results
xx_fit_para    = ener_para_str.FIT_ENER
yy_fit_para    = data_para_str.FIT_DATA
yerr___para    = onec_para_str.FIT_ONEC
ff_fit_para    = fit__para_str.YFIT
;;----------------------------------------------------------------------------------------
;;  Perpendicular Fit
;;----------------------------------------------------------------------------------------
param          = DBLARR(4)
param[0]       = 1d6                      ;;  Lim_{E --> Infinity} (dJ/dE) ~ 10^(6)
param[1]       = -2d0                     ;;  ¥ ~ 2
param[2]       = -1d0/1d2                 ;;  E_o ~ 100 eV
param[3]       = 0d0                      ;;  Lim_{E --> Infinity} (dJ/dE)_o ~ 0
bran           = [1,1,-7d0,-5d-2]         ;;  Constrain spectral index
cran           = [1,1,-1d0/1d1,-1d0/1d4]  ;;  Constrain E_o
fixed_p        = REPLICATE(1b,4)
fixed_p[3]     = 0b
fit_str_perp   = temp_fit_evdf_cut_wrapper(data0,energy0,pang0,perp_ra,param,$
                                           CUT_DIR=0e0,E_LOW=30e0,ONE_C=onec0,$
                                           B_RANGE=bran,C_RANGE=cran,FIXED_P=fixed_p)
;;  Define parameters
data_perp_str  = fit_str_perp.DATA
ener_perp_str  = fit_str_perp.ENERGY
onec_perp_str  = fit_str_perp.ONE_C
fit__perp_str  = fit_str_perp.FIT
Avgf_perp      = data_perp_str.AVG_DATA
AvgE_perp      = ener_perp_str.AVG_ENER
Avg1_perp      = onec_perp_str.AVG_ONEC

;;  Define fit results
xx_fit_perp    = ener_perp_str.FIT_ENER
yy_fit_perp    = data_perp_str.FIT_DATA
yerr___perp    = onec_perp_str.FIT_ONEC
ff_fit_perp    = fit__perp_str.YFIT
;;----------------------------------------------------------------------------------------
;;  Anti-parallel Fit
;;----------------------------------------------------------------------------------------
param          = DBLARR(4)
param[0]       = 1d6                      ;;  Lim_{E --> Infinity} (dJ/dE) ~ 10^(6)
param[1]       = -2d0                     ;;  ¥ ~ 2
param[2]       = -1d0/1d2                 ;;  E_o ~ 100 eV
param[3]       = 0d0                      ;;  Lim_{E --> Infinity} (dJ/dE)_o ~ 0
bran           = [1,1,-7d0,-5d-2]         ;;  Constrain spectral index
cran           = [1,1,-1d0/1d1,-1d0/1d4]  ;;  Constrain E_o
fixed_p        = REPLICATE(1b,4)
fixed_p[3]     = 0b
fit_str_anti   = temp_fit_evdf_cut_wrapper(data0,energy0,pang0,anti_ra,param,$
                                           CUT_DIR=0e0,E_LOW=30e0,ONE_C=onec0,$
                                           B_RANGE=bran,C_RANGE=cran,FIXED_P=fixed_p)
;;  Define parameters
data_anti_str  = fit_str_anti.DATA
ener_anti_str  = fit_str_anti.ENERGY
onec_anti_str  = fit_str_anti.ONE_C
fit__anti_str  = fit_str_anti.FIT
Avgf_anti      = data_anti_str.AVG_DATA
AvgE_anti      = ener_anti_str.AVG_ENER
Avg1_anti      = onec_anti_str.AVG_ONEC

;;  Define fit results
xx_fit_anti    = ener_anti_str.FIT_ENER
yy_fit_anti    = data_anti_str.FIT_DATA
yerr___anti    = onec_anti_str.FIT_ONEC
ff_fit_anti    = fit__anti_str.YFIT
;;----------------------------------------------------------------------------------------
;;  Plot results
;;----------------------------------------------------------------------------------------
xdat0          = AvgE_para
xdat1          = AvgE_perp
xdat2          = AvgE_anti
ydat0          = Avgf_para
ydat1          = Avgf_perp
ydat2          = Avgf_anti
;;  Define one-count levels for comparison
yone0          = Avg1_para
yone1          = Avg1_perp
yone2          = Avg1_anti
;;  Define fit results
xfit0          = xx_fit_para
xfit1          = xx_fit_perp
xfit2          = xx_fit_anti
yfit0          = ff_fit_para
yfit1          = ff_fit_perp
yfit2          = ff_fit_anti

WSET,2
WSHOW,2
PLOT,xdat0,ydat0,_EXTRA=limits,/NODATA
  OPLOT,xdat0,ydat0,COLOR=250,PSYM=2
  OPLOT,xdat1,ydat1,COLOR=150,PSYM=2
  OPLOT,xdat2,ydat2,COLOR= 50,PSYM=2
  ;;  Plot one-count levels
  OPLOT,xdat0,yone0,COLOR=250,LINESTYLE=2
  OPLOT,xdat1,yone1,COLOR=150,LINESTYLE=2
  OPLOT,xdat2,yone2,COLOR= 50,LINESTYLE=2

WSET,3
WSHOW,3
PLOT,AvgE_para,Avgf_para,_EXTRA=limits,/NODATA
  OPLOT,AvgE_para,Avgf_para,COLOR=250,PSYM=2
  OPLOT,AvgE_perp,Avgf_perp,COLOR=150,PSYM=2
  OPLOT,AvgE_anti,Avgf_anti,COLOR= 50,PSYM=2
  OPLOT,    xfit0,    yfit0,COLOR=250,LINESTYLE=2
  OPLOT,    xfit1,    yfit1,COLOR=150,LINESTYLE=2
  OPLOT,    xfit2,    yfit2,COLOR= 50,LINESTYLE=2

STOP

;;----------------------------------------------------------------------------------------
;;  Define parameters
;;----------------------------------------------------------------------------------------
;;  Sort by pitch-angle
sp             = SORT(pang)
pang           = pang[sp]
pa_cols        = pa_cols[sp]
data_pa        = data0[*,sp]
ener_pa        = energy0[*,sp]
onec_pa        = onec0[*,sp]
;;  Define parallel, anti-parallel, and perpendicular
para_ra        = [0d0,2d1]
anti_ra        = [16d1,18d1]
perp_ra        = [8d1,10d1]
test_para      = (pang GE para_ra[0]) AND (pang LE para_ra[1])
test_perp      = (pang GE perp_ra[0]) AND (pang LE perp_ra[1])
test_anti      = (pang GE anti_ra[0]) AND (pang LE anti_ra[1])
good_para      = WHERE(test_para,gd_para,COMPLEMENT=bad_para,NCOMPLEMENT=bd_para)
good_perp      = WHERE(test_perp,gd_perp,COMPLEMENT=bad_perp,NCOMPLEMENT=bd_perp)
good_anti      = WHERE(test_anti,gd_anti,COMPLEMENT=bad_anti,NCOMPLEMENT=bd_anti)
;;  Make sure finite values exist for these
IF (gd_para EQ 0) THEN BEGIN
  ;;  Nothing within 20 degrees of 0 was found --> No parallel fit
  parallel_fit = 0
ENDIF
IF (gd_perp EQ 0) THEN BEGIN
  ;;  Nothing within 20 degrees of 90 was found --> No perpendicular fit
  perpendi_fit = 0
ENDIF
IF (gd_anti EQ 0) THEN BEGIN
  ;;  Nothing within 20 degrees of 180 was found --> No anti-parallel fit
  antipara_fit = 0
ENDIF
;;----------------------------------------------------------------------------------------
;;  Parallel Fit
;;----------------------------------------------------------------------------------------
IF (gd_para GT 0) THEN BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Good values found --> try to fit
  ;;--------------------------------------------------------------------------------------
  ;;  Find PA bin closest to parallel, perpendicular, and anti-parallel for one-count
  pang_para      = pang[good_para]
  diff_para      = MIN(ABS( 0d0 - pang_para),gind_para,/NAN)
  ;;  Define data and energy in each direction
  data_para      = data_pa[*,good_para]
  ener_para      = ener_pa[*,good_para]
  onec_para      = onec_pa[*,good_para[gind_para[0]]]
  ;;  Average data over each direction
  Avgf_para      = TOTAL(data_para,2L,/NAN)/TOTAL(FINITE(data_para),2L,/NAN)
  AvgE_para      = TOTAL(ener_para,2L,/NAN)/TOTAL(FINITE(ener_para),2L,/NAN)
  Avg1_para      = onec_para
  ;;--------------------------------------------------------------------------------------
  ;;  Try fitting to Y = A X^(B) e^(C X) + D
  ;;
  ;;    Y  =  dJ/dE [flux units]
  ;;    X  =  E  [eV]
  ;;    A  =  K  [some constant]
  ;;    B  =  -¥ = power-law slope = spectral index
  ;;    C  =  -1/E_o, E_o = e-folding energy [eV]
  ;;    D  =  (dJ/dE)_o = limit as E --> 0
  ;;--------------------------------------------------------------------------------------
  ;;  Use only those elements which satisfy the following two constraints:
  ;;    1)  E > 30 eV
  ;;    2)  f > f_1c    [f_1c = one-count level]
  e_low          = 30e0
  test_para_fit  =  (AvgE_para GE e_low[0]) AND $
                   ((Avgf_para GE Avg1_para) AND (Avgf_para GT 0) AND FINITE(Avgf_para))
  good_para_fit  = WHERE(test_para_fit,gd_para_fit,COMPLEMENT=bad_para_fit,NCOMPLEMENT=bd_para_fit)
  IF (gd_para_fit GT 0) THEN BEGIN
    x              = AvgE_para[good_para_fit]
    y              = Avgf_para[good_para_fit]
    yerr           = ABS(Avg1_para[good_para_fit])
    wghts          = 1d0/ABS(yerr)            ;;  Poisson weighting
    func           = 4                        ;;  i.e., Y = A X^(B) e^(C X) + D
    param          = DBLARR(4)
    param[0]       = 1d6                      ;;  Lim_{E --> Infinity} (dJ/dE) ~ 10^(6)
    param[1]       = -2d0                     ;;  ¥ ~ 2
    param[2]       = -1d0/1d2                 ;;  E_o ~ 100 eV
    param[3]       = 0d0                      ;;  Lim_{E --> Infinity} (dJ/dE)_o ~ 0
    bran           = [1,1,-7d0,-5d-2]         ;;  Constrain spectral index
    cran           = [1,1,-1d0/1d1,-1d0/1d4]  ;;  Constrain E_o
    fixed_p        = REPLICATE(1b,4)
    fixed_p[3]     = 0b
    fit_str_para   = wrapper_multi_func_fit(x,y,param,FIT_FUNC=func[0],ERROR=yerr,  $
                                            WEIGHTS=wghts,B_RANGE=bran,C_RANGE=cran,$
                                            FIXED_P=fixed_p)
    IF (SIZE(fit_str_para,/TYPE) NE 8L) THEN BEGIN
      x            = dumb10
      fit_str_para = d_fit_struc
    ENDIF
  ENDIF ELSE BEGIN
    ;;  No finite data within constraints --> use dummy values
    x            = dumb10
    fit_str_para = d_fit_struc
  ENDELSE
ENDIF ELSE BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Nothing within 20 degrees of 0 was found --> No parallel fit
  ;;--------------------------------------------------------------------------------------
  pang_para      = dumb10
  diff_para      = dumb10
  data_para      = dumb10
  ener_para      = dumb10
  onec_para      = dumb10
  Avgf_para      = dumb10
  AvgE_para      = dumb10
  Avg1_para      = dumb10
  x              = dumb10
  fit_str_para   = d_fit_struc
ENDELSE
;;  Define fit results
xx_fit_para    = x
ff_fit_para    = fit_str_para.YFIT
;;----------------------------------------------------------------------------------------
;;  Perpendicular Fit
;;----------------------------------------------------------------------------------------
IF (gd_perp GT 0) THEN BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Good values found --> try to fit
  ;;--------------------------------------------------------------------------------------
  ;;  Find PA bin closest to perpendicular for one-count
  pang_perp      = pang[good_perp]
  diff_perp      = MIN(ABS(90d0 - pang_perp),gind_perp,/NAN)
  ;;  Define data and energy in each direction
  data_perp      = data_pa[*,good_perp]
  ener_perp      = ener_pa[*,good_perp]
  onec_perp      = onec_pa[*,good_perp[gind_perp[0]]]
  ;;  Average data over each direction
  Avgf_perp      = TOTAL(data_perp,2L,/NAN)/TOTAL(FINITE(data_perp),2L,/NAN)
  AvgE_perp      = TOTAL(ener_perp,2L,/NAN)/TOTAL(FINITE(ener_perp),2L,/NAN)
  Avg1_perp      = onec_perp
  ;;--------------------------------------------------------------------------------------
  ;;  Try fitting to Y = A X^(B) e^(C X) + D
  ;;
  ;;    Y  =  dJ/dE [flux units]
  ;;    X  =  E  [eV]
  ;;    A  =  K  [some constant]
  ;;    B  =  -¥ = power-law slope = spectral index
  ;;    C  =  -1/E_o, E_o = e-folding energy [eV]
  ;;    D  =  (dJ/dE)_o = limit as E --> 0
  ;;--------------------------------------------------------------------------------------
  ;;  Use only those elements which satisfy the following two constraints:
  ;;    1)  E > 30 eV
  ;;    2)  f > f_1c    [f_1c = one-count level]
  e_low          = 30e0
  test_perp_fit  =  (AvgE_perp GE e_low[0]) AND $
                   ((Avgf_perp GE Avg1_perp) AND (Avgf_perp GT 0) AND FINITE(Avgf_perp))
  good_perp_fit  = WHERE(test_perp_fit,gd_perp_fit,COMPLEMENT=bad_perp_fit,NCOMPLEMENT=bd_perp_fit)
  IF (gd_perp_fit GT 0) THEN BEGIN
    x              = AvgE_perp[good_perp_fit]
    y              = Avgf_perp[good_perp_fit]
    yerr           = ABS(Avg1_perp[good_perp_fit])
    wghts          = 1d0/ABS(yerr)            ;;  Poisson weighting
    func           = 4                        ;;  i.e., Y = A X^(B) e^(C X) + D
    param          = DBLARR(4)
    param[0]       = 1d6                      ;;  Lim_{E --> Infinity} (dJ/dE) ~ 10^(6)
    param[1]       = -2d0                     ;;  ¥ ~ 2
    param[2]       = -1d0/1d2                 ;;  E_o ~ 100 eV
    param[3]       = 0d0                      ;;  Lim_{E --> Infinity} (dJ/dE)_o ~ 0
    bran           = [1,1,-7d0,-5d-2]         ;;  Constrain spectral index
    cran           = [1,1,-1d0/1d1,-1d0/1d4]  ;;  Constrain E_o
    fixed_p        = REPLICATE(1b,4)
    fixed_p[3]     = 0b
    fit_str_perp   = wrapper_multi_func_fit(x,y,param,FIT_FUNC=func[0],ERROR=yerr,  $
                                            WEIGHTS=wghts,B_RANGE=bran,C_RANGE=cran,$
                                            FIXED_P=fixed_p)
    IF (SIZE(fit_str_perp,/TYPE) NE 8L) THEN BEGIN
      x            = dumb10
      fit_str_perp = d_fit_struc
    ENDIF
  ENDIF ELSE BEGIN
    ;;  No finite data within constraints --> use dummy values
    x            = dumb10
    fit_str_perp = d_fit_struc
  ENDELSE
ENDIF ELSE BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Nothing within 20 degrees of 90 was found --> No perpendicular fit
  ;;--------------------------------------------------------------------------------------
  pang_perp      = dumb10
  diff_perp      = dumb10
  data_perp      = dumb10
  ener_perp      = dumb10
  onec_perp      = dumb10
  Avgf_perp      = dumb10
  AvgE_perp      = dumb10
  Avg1_perp      = dumb10
  x              = dumb10
  fit_str_perp   = d_fit_struc
ENDELSE
;;  Define fit results
xx_fit_perp    = x
ff_fit_perp    = fit_str_perp.YFIT
;;----------------------------------------------------------------------------------------
;;  Anti-parallel Fit
;;----------------------------------------------------------------------------------------
IF (gd_anti GT 0) THEN BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Good values found --> try to fit
  ;;--------------------------------------------------------------------------------------
  ;;  Find PA bin closest to anti-parallel for one-count
  pang_anti      = pang[good_anti]
  diff_anti      = MIN(ABS(18d1 - pang_anti),gind_anti,/NAN)
  ;;  Define data and energy in each direction
  data_anti      = data_pa[*,good_anti]
  ener_anti      = ener_pa[*,good_anti]
  onec_anti      = onec_pa[*,good_anti[gind_anti[0]]]
  ;;  Average data over each direction
  Avgf_anti      = TOTAL(data_anti,2L,/NAN)/TOTAL(FINITE(data_anti),2L,/NAN)
  AvgE_anti      = TOTAL(ener_anti,2L,/NAN)/TOTAL(FINITE(ener_anti),2L,/NAN)
  Avg1_anti      = onec_anti
  ;;--------------------------------------------------------------------------------------
  ;;  Try fitting to Y = A X^(B) e^(C X) + D
  ;;
  ;;    Y  =  dJ/dE [flux units]
  ;;    X  =  E  [eV]
  ;;    A  =  K  [some constant]
  ;;    B  =  -¥ = power-law slope = spectral index
  ;;    C  =  -1/E_o, E_o = e-folding energy [eV]
  ;;    D  =  (dJ/dE)_o = limit as E --> 0
  ;;--------------------------------------------------------------------------------------
  ;;  Use only those elements which satisfy the following two constraints:
  ;;    1)  E > 30 eV
  ;;    2)  f > f_1c    [f_1c = one-count level]
  e_low          = 30e0
  test_anti_fit  =  (AvgE_anti GE e_low[0]) AND $
                   ((Avgf_anti GE Avg1_anti) AND (Avgf_anti GT 0) AND FINITE(Avgf_anti))
  good_anti_fit  = WHERE(test_anti_fit,gd_anti_fit,COMPLEMENT=bad_anti_fit,NCOMPLEMENT=bd_anti_fit)
  IF (gd_anti_fit GT 0) THEN BEGIN
    x              = AvgE_anti[good_anti_fit]
    y              = Avgf_anti[good_anti_fit]
    yerr           = ABS(Avg1_anti[good_anti_fit])
    wghts          = 1d0/ABS(yerr)            ;;  Poisson weighting
    func           = 4                        ;;  i.e., Y = A X^(B) e^(C X) + D
    param          = DBLARR(4)
    param[0]       = 1d6                      ;;  Lim_{E --> Infinity} (dJ/dE) ~ 10^(6)
    param[1]       = -2d0                     ;;  ¥ ~ 2
    param[2]       = -1d0/1d2                 ;;  E_o ~ 100 eV
    param[3]       = 0d0                      ;;  Lim_{E --> Infinity} (dJ/dE)_o ~ 0
    bran           = [1,1,-7d0,-5d-2]         ;;  Constrain spectral index
    cran           = [1,1,-1d0/1d1,-1d0/1d4]  ;;  Constrain E_o
    fixed_p        = REPLICATE(1b,4)
    fixed_p[3]     = 0b
    fit_str_anti   = wrapper_multi_func_fit(x,y,param,FIT_FUNC=func[0],ERROR=yerr,  $
                                            WEIGHTS=wghts,B_RANGE=bran,C_RANGE=cran,$
                                            FIXED_P=fixed_p)
    IF (SIZE(fit_str_anti,/TYPE) NE 8L) THEN BEGIN
      x            = dumb10
      fit_str_anti = d_fit_struc
    ENDIF
  ENDIF ELSE BEGIN
    ;;  No finite data within constraints --> use dummy values
    x            = dumb10
    fit_str_anti = d_fit_struc
  ENDELSE
ENDIF ELSE BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Nothing within 20 degrees of 180 was found --> No anti-parallel fit
  ;;--------------------------------------------------------------------------------------
  pang_anti      = dumb10
  diff_anti      = dumb10
  data_anti      = dumb10
  ener_anti      = dumb10
  onec_anti      = dumb10
  Avgf_anti      = dumb10
  AvgE_anti      = dumb10
  Avg1_anti      = dumb10
  x              = dumb10
  fit_str_anti   = d_fit_struc
ENDELSE
;;  Define fit results
xx_fit_anti    = x
ff_fit_anti    = fit_str_anti.YFIT
;;----------------------------------------------------------------------------------------
;;  Plot results
;;----------------------------------------------------------------------------------------










END



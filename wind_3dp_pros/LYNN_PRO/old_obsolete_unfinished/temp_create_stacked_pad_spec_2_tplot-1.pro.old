;*****************************************************************************************
;
;  FUNCTION :   temp_calc_pad_spect.pro
;  PURPOSE  :   This routine calculates the pitch-angle distributions (PADs) from an
;                 input array of 3D particle velocity distributions.  The results are
;                 very similar to those returned by get_padspecs.pro.
;
;  CALLED BY:   
;               temp_create_stacked_pad_spec_2_tplot.pro
;
;  CALLS:
;               test_wind_vs_themis_esa_struct.pro
;               dat_3dp_str_names.pro
;               dat_themis_esa_str_names.pro
;               str_element.pro
;               wind_3dp_units.pro
;               format_esa_bins_keyword.pro
;               struct_value.pro
;               transform_vframe_3d.pro
;               conv_units.pro     **  Only UMN/3DP version can handle arrays **
;               pad.pro
;               themis_esa_pad.pro
;               calc_log_scale_yrange.pro
;               extract_tags.pro
;
;  REQUIRES:    
;               1)  UMN Modified Wind/3DP IDL Libraries
;
;  INPUT:
;               DAT         :  [N]-Element [structure] array of THEMIS ESA or Wind/3DP
;                                IDL data structures containing the 3D velocity
;                                distribution functions to use to create the stacked
;                                energy spectra as pitch-angle distributions
;
;  EXAMPLES:    
;               test = temp_calc_pad_spect(dat,UNITS='eflux',BINS=bins,NUM_PA=9L)
;
;  KEYWORDS:    
;               UNITS       :  Scalar [string] defining the units to use for the
;                                vertical axis of the plot and the outputs YDAT and DYDAT
;                                [Default = 'flux' or number flux]
;               BINS        :  [N]-Element [byte] array defining which solid angle bins
;                                should be plotted [i.e., BINS[good] = 1b] and which
;                                bins should not be plotted [i.e., BINS[bad] = 0b].
;                                One can also define bins as an array of indices that
;                                define which solid angle bins to plot.  If this is the
;                                case, then on output, BINS will be redefined to an
;                                array of byte values specifying which bins are TRUE or
;                                FALSE.
;                                [Default:  BINS[*] = 1b]
;               TRANGE      :  [2]-Element [double] array of Unix times specifying the
;                                time range over which to calculate spectra
;                                [Default : [MIN(DAT.TIME),MAX(DAT.END_TIME)] ]
;               ERANGE      :  [2]-Element [double] array defining the energy [eV] range
;                                over which to calculate spectra
;                                [Default : [MIN(DAT.ENERGY),MAX(DAT.ENERGY)] ]
;               NUM_PA      :  Scalar [integer] that defines the number of pitch-angle
;                                bins to calculate for the resulting distribution
;                                [Default = 8]
;               LIMITS      :  Scalar [structure] that may contain any combination of the
;                                following structure tags or keywords accepted by
;                                PLOT.PRO:
;                                  XLOG,   YLOG,   ZLOG,
;                                  XRANGE, YRANGE, ZRANGE,
;                                  XTITLE, YTITLE,
;                                  TITLE, POSITION, REGION, etc.
;                                  (see IDL documentation for a description)
;               NO_TRANS    :  If set, routine will not transform data into bulk flow
;                                rest frame defined by the structure tag VSW in each
;                                DAT structure (VELOCITY tag in THEMIS ESA structures
;                                will work as well so long as the THETA/PHI angles are
;                                in the same coordinate basis as VELOCITY and MAGF)
;                                [Default = FALSE]
;
;   CHANGED:  1)  Continued to write routine
;                                                                   [02/10/2015   v1.0.0]
;
;   NOTES:      
;               1)  See also:  get_spec.pro, get_padspecs.pro, calc_padspecs.pro
;               2)  The following structure tags must be defined in DAT
;                     MAGF, (VSW or VELOCITY), and {usual 3DP and ESA tags}
;
;  REFERENCES:  
;               1)  Carlson et al., (1983), "An instrument for rapidly measuring
;                      plasma distribution functions with high resolution,"
;                      Adv. Space Res. Vol. 2, pp. 67-70.
;               2)  Curtis et al., (1989), "On-board data analysis techniques for
;                      space plasma particle instruments," Rev. Sci. Inst. Vol. 60,
;                      pp. 372.
;               3)  Lin et al., (1995), "A Three-Dimensional Plasma and Energetic
;                      particle investigation for the Wind spacecraft," Space Sci. Rev.
;                      Vol. 71, pp. 125.
;               4)  Paschmann, G. and P.W. Daly (1998), "Analysis Methods for Multi-
;                      Spacecraft Data," ISSI Scientific Report, Noordwijk, 
;                      The Netherlands., Int. Space Sci. Inst.
;               5)  McFadden, J.P., C.W. Carlson, D. Larson, M. Ludlam, R. Abiad,
;                      B. Elliot, P. Turin, M. Marckwordt, and V. Angelopoulos
;                      "The THEMIS ESA Plasma Instrument and In-flight Calibration,"
;                      Space Sci. Rev. 141, pp. 277-302, (2008).
;               6)  McFadden, J.P., C.W. Carlson, D. Larson, J.W. Bonnell,
;                      F.S. Mozer, V. Angelopoulos, K.-H. Glassmeier, U. Auster
;                      "THEMIS ESA First Science Results and Performance Issues,"
;                      Space Sci. Rev. 141, pp. 477-508, (2008).
;               7)  Auster, H.U., K.-H. Glassmeier, W. Magnes, O. Aydogar, W. Baumjohann,
;                      D. Constantinescu, D. Fischer, K.H. Fornacon, E. Georgescu,
;                      P. Harvey, O. Hillenmaier, R. Kroth, M. Ludlam, Y. Narita,
;                      R. Nakamura, K. Okrafka, F. Plaschke, I. Richter, H. Schwarzl,
;                      B. Stoll, A. Valavanoglou, and M. Wiedemann "The THEMIS Fluxgate
;                      Magnetometer," Space Sci. Rev. 141, pp. 235-264, (2008).
;               8)  Angelopoulos, V. "The THEMIS Mission," Space Sci. Rev. 141,
;                      pp. 5-34, (2008).
;
;   CREATED:  02/06/2015
;   CREATED BY:  Lynn B. Wilson III
;    LAST MODIFIED:  02/10/2015   v1.0.0
;    MODIFIED BY: Lynn B. Wilson III
;
;*****************************************************************************************

FUNCTION temp_calc_pad_spect,dat,UNITS=units,BINS=bins,TRANGE=trange,ERANGE=erange,$
                                 NUM_PA=num_pa,LIMITS=limits,NO_TRANS=no_trans

;;  Let IDL know that the following are functions
FORWARD_FUNCTION test_wind_vs_themis_esa_struct, dat_3dp_str_names,                 $
                 dat_themis_esa_str_names, wind_3dp_units, format_esa_bins_keyword, $
                 struct_value, conv_units, pad, themis_esa_pad, calc_log_scale_yrange
;;----------------------------------------------------------------------------------------
;;  Define some constants and dummy variables
;;----------------------------------------------------------------------------------------
f              = !VALUES.F_NAN
d              = !VALUES.D_NAN
mission_logic  = [0b,0b]                ;;  Logic variable used for determining which mission is associated with DAT
;;  Define allowed number types
isnum          = [1,2,3,4,5,6,12,13,14,15]
;;  Dummy error messages
noinpt_msg     = 'User must supply an array of velocity distribution functions as IDL structures...'
notstr_msg     = 'DAT must be an array of IDL structures...'
notvdf_msg     = 'Input must be a velocity distribution function as an IDL structure...'
badtra_msg     = 'TRANGE must be a 2-element array of Unix times and DAT must have a range of times as well...'
badera_msg     = 'ERANGE must be a 2-element array of energies [eV] and DAT.ENERGY must have a range of energies as well...'
badmag_msg     = 'DAT structure must have MAGF tag defined as a 3 element vector of cartesian magnetic field components'
badvsw_msg     = 'DAT structure must have VSW (or VELOCITY) tag defined as a 3 element vector of cartesian magnetic field components'
;;----------------------------------------------------------------------------------------
;;  Check input
;;----------------------------------------------------------------------------------------
IF (N_PARAMS() LT 1) THEN BEGIN
  MESSAGE,noinpt_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
IF (SIZE(dat,/TYPE) NE 8L OR N_ELEMENTS(dat) LT 2) THEN BEGIN
  MESSAGE,notstr_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
;;  Check to make sure distribution has the correct format
test0          = test_wind_vs_themis_esa_struct(dat[0],/NOM)
test           = (test0.(0) + test0.(1)) NE 1
IF (test[0]) THEN BEGIN
  MESSAGE,notvdf_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
;;  Determine instrument (i.e., ESA or 3DP) and define electric charge
dat0           = dat[0]
IF (test0.(0)) THEN BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Wind
  ;;--------------------------------------------------------------------------------------
  mission      = 'Wind'
  strns        = dat_3dp_str_names(dat0[0])
  IF (SIZE(strns,/TYPE) NE 8) THEN BEGIN
    ;;  Neither Wind/3DP nor THEMIS/ESA VDF
    MESSAGE,not3dp_msg[0],/INFORMATIONAL,/CONTINUE
    RETURN,0b
  ENDIF
  inst_nm_mode = strns.LC[0]         ;;  e.g., 'Pesa Low Burst'
  pad_func     = 'pad'               ;;  pad.pro routine to be called for Wind/3DP distributions
ENDIF ELSE BEGIN
  IF (test0.(1)) THEN BEGIN
    ;;------------------------------------------------------------------------------------
    ;;  THEMIS
    ;;------------------------------------------------------------------------------------
    mission      = 'THEMIS'
    strns        = dat_themis_esa_str_names(dat0[0])
    IF (SIZE(strns,/TYPE) NE 8) THEN BEGIN
      ;;  Neither Wind/3DP nor THEMIS/ESA VDF
      MESSAGE,notthm_msg[0],/INFORMATIONAL,/CONTINUE
      RETURN,0b
    ENDIF
    temp         = strns.LC[0]                  ;;  e.g., 'IESA 3D Reduced Distribution'
    tposi        = STRPOS(temp[0],'Distribution') - 1L
    inst_nm_mode = STRMID(temp[0],0L,tposi[0])  ;;  e.g., 'IESA 3D Reduced'
    pad_func     = 'themis_esa_pad'             ;;  themis_esa_pad.pro routine to be called for THEMIS/ESA distributions
  ENDIF ELSE BEGIN
    ;;------------------------------------------------------------------------------------
    ;;  Other mission?
    ;;------------------------------------------------------------------------------------
    ;;  Not handling any other missions yet
    MESSAGE,badvdf_msg[0],/INFORMATIONAL,/CONTINUE
    RETURN,0b
  ENDELSE
ENDELSE
mission_logic  = [(test0.(0))[0],(test0.(1))[0]]
data_str       = strns.SN[0]     ;;  e.g., 'el' for Wind EESA Low or 'peeb' for THEMIS EESA
;;----------------------------------------------------------------------------------------
;;  Define parameters relevant to structure format
;;----------------------------------------------------------------------------------------
n_dat          = N_ELEMENTS(dat)        ;;  # of data structures
n_b            = dat[0].NBINS[0]        ;;  # of solid angle bins per structure
n_e            = dat[0].NENERGY[0]      ;;  # of energy bins per structure
;;  Check for MAGF and make sure it has valid values
str_element,dat[0],'MAGF',magf
test           = (N_ELEMENTS(magf) NE 3)
IF (test[0]) THEN BEGIN
  MESSAGE,'TAG:  '+badmag_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
magf           = dat.MAGF
test           = (TOTAL(FINITE(magf)) EQ 0) OR (TOTAL(ABS(magf)) EQ 0)
IF (test[0]) THEN BEGIN
  MESSAGE,'FINITE:  '+badmag_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
;;----------------------------------------------------------------------------------------
;;  Check keywords
;;----------------------------------------------------------------------------------------
;;  Check UNITS
test           = (N_ELEMENTS(units) EQ 0) OR (SIZE(units,/TYPE) NE 7)
IF (test[0]) THEN units = 'flux'
;;  Format to allowable units
temp           = wind_3dp_units(units)
gunits         = temp.G_UNIT_NAME      ;;  e.g. 'flux'
units          = gunits[0]             ;;  redefine UNITS incase it changed
;;  Check ERANGE
sznt0          = SIZE(erange,/TYPE)
test           = (N_ELEMENTS(erange) NE 2) OR (TOTAL(sznt0[0] EQ isnum) EQ 0)
ener0          = dat.ENERGY
;;  Default energy range [eV]
;;    --> Need the extra ±1% to prevent averaging from removing energy bins if user
;;        in case user did not set ERANGE
def_eran       = [MIN(ener0,/NAN),MAX(ener0,/NAN)]*[0.99,1.01]
IF (test[0]) THEN eran = def_eran ELSE eran = [MIN(erange),MAX(erange)]
test           = (eran[0] EQ eran[1]) AND (def_eran[0] EQ def_eran[1])
IF (test[0]) THEN BEGIN
  MESSAGE,badera_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF ELSE BEGIN
  IF (eran[0] EQ eran[1]) THEN eran = def_eran
ENDELSE
;;  Clean up
ener0          = 0
;;  Check TRANGE
sznt0          = SIZE(trange,/TYPE)
test           = (N_ELEMENTS(trange) NE 2) OR (TOTAL(sznt0[0] EQ isnum) EQ 0)
IF (test[0]) THEN tra = [MIN(dat.TIME),MAX(dat.END_TIME)] ELSE tra = [MIN(trange),MAX(trange)]
test           = (N_ELEMENTS(tra) NE 2) OR (tra[0] EQ tra[1])
IF (test[0]) THEN BEGIN
  MESSAGE,badtra_msg,/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
;;  Check BINS
bstr           = format_esa_bins_keyword(dat,BINS=bins)
test           = (SIZE(bstr,/TYPE) NE 8)
IF (test[0]) THEN STOP     ;;  Debug --> something is wrong
;;  Check NUM_PA
sznt0          = SIZE(num_pa,/TYPE)
test           = (N_ELEMENTS(num_pa) EQ 0) OR (TOTAL(sznt0[0] EQ isnum) EQ 0)
IF (test[0]) THEN n_pa = 8L ELSE n_pa = num_pa[0]
;;  Check NO_TRANS
test           = ~KEYWORD_SET(no_trans)
IF (test[0]) THEN BEGIN
  ;;  User wants to transform into bulk flow rest frame
  ;;    --> Need the VSW (or VELOCITY) structure tag
  str_element,dat[0],'VSW',vsw
  test           = (N_ELEMENTS(vsw) NE 3)
  IF (test[0]) THEN str_element,dat[0],'VELOCITY',vsw
  test           = (N_ELEMENTS(vsw) NE 3)
  IF (test[0]) THEN BEGIN
    MESSAGE,'TAG:  '+badvsw_msg,/INFORMATIONAL,/CONTINUE
    RETURN,0b
  ENDIF
  alltags        = STRLOWCASE(TAG_NAMES(dat[0]))
  good0          = WHERE(alltags EQ 'vsw',gd0)
  good1          = WHERE(alltags EQ 'velocity',gd1)
  test           = (gd0 GT 0)
  IF (test[0]) THEN vsw = dat.(good0[0]) ELSE vsw = dat.(good1[0])
  test           = (TOTAL(FINITE(vsw)) EQ 0) OR (TOTAL(ABS(vsw)) EQ 0)
  IF (test[0]) THEN BEGIN
    MESSAGE,'FINITE:  '+badvsw_msg,/INFORMATIONAL,/CONTINUE
    RETURN,0b
  ENDIF
  ;;  Set transformation logic
  yes_trans = 1
ENDIF ELSE yes_trans = 0
IF (yes_trans[0]) THEN f_suffx = 'swf' ELSE f_suffx = 'scf'
;;----------------------------------------------------------------------------------------
;;  Define data parameters
;;----------------------------------------------------------------------------------------
;;  Keep DAT within TRANGE
test           = (dat.TIME GE tra[0]) AND (dat.END_TIME LE tra[1])
good           = WHERE(test,gd,COMPLEMENT=bad,NCOMPLEMENT=bd)
IF (gd[0] GT 0 AND gd[0] LT n_dat[0]) THEN BEGIN
  ;;  Remove data out of time range
  dat2   = dat[good]
ENDIF ELSE BEGIN
  dat2   = dat ;;  Else --> use all
ENDELSE
;;  Keep DAT.ENERGY within ERANGE
ener0          = TOTAL(dat.ENERGY,3L,/NAN)/TOTAL(FINITE(dat.ENERGY),3L,/NAN)    ;;  [E,A]-Element array
ener1          = TOTAL(ener0,2L,/NAN)/TOTAL(FINITE(ener0),2L,/NAN)              ;;  [E]-Element array

n_all_en       = N_ELEMENTS(ener0)
test           = (ener1 GE eran[0]) AND (ener1 LE eran[1])
good           = WHERE(test,gd,COMPLEMENT=bad,NCOMPLEMENT=bd)
test           = (gd[0] GT 0) AND (bd[0] LT (n_e[0] - 1L))
IF (test[0]) THEN BEGIN
  ;;  Use only the good (average) energy bins
  good_eind        = good
ENDIF ELSE BEGIN
  ;;  Else --> use all
  good_eind        = LINDGEN(n_e[0])
ENDELSE
avg_ener_out   = ener1[good_eind]
;;  Redefine # of structures and data
;;    E = # of energy bins per structure
;;    A = # solid angle bins per energy per structure
;;    D = # of structures
n_dat          = N_ELEMENTS(dat2)                          ;;  # of data structures
n_e_out        = N_ELEMENTS(good_eind)                     ;;  # of energy bins to use on output
pad_time       = REPLICATE(d,n_dat[0])                     ;;  Unix times associated with each PAD
pad_data       = REPLICATE(f,n_dat[0],n_e_out[0],n_pa[0])  ;;  PAD data array [UNITS]
pad_ener       = REPLICATE(f,n_dat[0],n_e_out[0])          ;;  PAD energy bin array [eV]
pad_pang       = REPLICATE(f,n_dat[0],n_pa[0])             ;;  PAD pitch-angle bin array [degrees]
;;  Test pitch-angle range
pa_range       = REPLICATE(f,n_dat[0],2L)
;;----------------------------------------------------------------------------------------
;;  Calculate pitch-angle distributions (PADs)
;;----------------------------------------------------------------------------------------
FOR i=0L, n_dat[0] - 1L DO BEGIN
  tdat          = dat2[i]
  pad_time[i]   = (tdat[0].TIME + tdat[0].END_TIME)/2d0
  IF (yes_trans[0]) THEN BEGIN
    ;;  Transform into bulk flow frame [if VSW or VELOCITY is set and defined]
    vsw            = struct_value(tdat,'VSW')
    test           = (N_ELEMENTS(vsw) NE 3)
    IF (test[0]) THEN vsw = struct_value(tdat,'VELOCITY')
    test           = (N_ELEMENTS(vsw) NE 3)
    IF (test[0]) THEN CONTINUE       ;;  User wants bulk flow frame --> skip this structure
    ;;  VSW or VELOCITY was set --> transform into bulk flow frame
    transform_vframe_3d,tdat,/EASY_TRAN
  ENDIF
  ;;--------------------------------------------------------------------------------------
  ;;  Convert to user defined units
  ;;--------------------------------------------------------------------------------------
  tdat          = conv_units(tdat[0],gunits[0])
  ;;--------------------------------------------------------------------------------------
  ;;  Calculate PAD
  ;;--------------------------------------------------------------------------------------
  ;;  ** think about SPIKES keyword for EESA High if bad bins don't work **
  pad0          = CALL_FUNCTION(pad_func[0],tdat,NUM_PA=n_pa[0],BINS=bins)
  test          = (SIZE(pad0,/TYPE) NE 8)
  IF (test[0]) THEN CONTINUE       ;;  Non-structure format return --> skip this index
  test          = (pad0[0].VALID EQ 1)
  IF (test[0]) THEN pad_data[i,*,*] = pad0[0].DATA[good_eind,*]
  ;;  Test pitch-angle range
  paran0        = [MIN(pad0[0].ANGLES[good_eind,*],/NAN),MAX(pad0[0].ANGLES[good_eind,*],/NAN)]
  testa         = [(paran0[0] GT 0) AND FINITE(paran0[0]),(paran0[1] GT 0) AND FINITE(paran0[1])]
  FOR k=0L, 1L DO IF (testa[k]) THEN pa_range[i,k] = paran0[k]
  ;;--------------------------------------------------------------------------------------
  ;;  Average energies over PAs and PAs over energies
  ;;--------------------------------------------------------------------------------------
  ;;  pad0.ANGLES = [E,A]-Element array
  count_pa      = TOTAL(FINITE(pad0[0].ANGLES[good_eind,*]),2,/NAN)   ;;  [E]-Element array = # of finite PAs
  count_en      = TOTAL(FINITE(pad0[0].ENERGY[good_eind,*]),1,/NAN)   ;;  [A]-Element array = # of finite energies
  temp__en      = TOTAL(pad0[0].ENERGY[good_eind,*],2,/NAN)/count_pa  ;;  sum energy bins over PAs 
  temp__pa      = TOTAL(pad0[0].ANGLES[good_eind,*],1,/NAN)/count_en  ;;  sum PA bins over energies
;  temp__pa      = TOTAL(pad0[0].ENERGY[good_eind,*],2,/NAN)/count_pa
;  temp__en      = TOTAL(pad0[0].ANGLES[good_eind,*],1,/NAN)/count_en
  ;;--------------------------------------------------------------------------------------
  ;;  Remove NaNs in energies if possible
  ;;--------------------------------------------------------------------------------------
  bad_en        = WHERE(temp__en LE 0 OR FINITE(temp__en) EQ 0,bd_en,COMPLEMENT=good_en,NCOMPLEMENT=gd_en)
  IF (bd_en GT 0) THEN BEGIN
    ;;  Try using the average energies from all structures to fill bad energy bins
    temp__en[bad_en] = avg_ener_out[bad_en]
  ENDIF
;  pad_ener[i,*] = temp__pa
;  pad_pang[i,*] = temp__en
  pad_ener[i,*] = temp__en
  pad_pang[i,*] = temp__pa
  ;;  --> Next iteration
ENDFOR
;;----------------------------------------------------------------------------------------
;;  Remove NaNs in PAs if possible
;;----------------------------------------------------------------------------------------
test           = (pad_pang LE 0) OR (pad_pang GT 180) OR (FINITE(pad_pang) EQ 0)
bad_pa         = WHERE(test,bd_pa,COMPLEMENT=good_pa,NCOMPLEMENT=gd_pa)
IF (bd_en GT 0) THEN BEGIN
  ;;  Try using the average PAs from all structures to fill bad PA bins
  count_pa      = TOTAL(FINITE(pad_pang),1,/NAN)  ;;  # of finite PAs
  temp__pa      = TOTAL(pad_pang,1,/NAN)/count_pa
  bind          = ARRAY_INDICES(pad_pang,bad_pa)
  new_angs      = REPLICATE(1e0,n_dat[0]) # temp__pa
  ;;  Redefine "bad" PAs to averages
  pad_pang[bind[0,*],bind[1,*]] = new_angs[bind[0,*],bind[1,*]]
ENDIF
;;----------------------------------------------------------------------------------------
;;  Define labels and colors for TPLOT
;;----------------------------------------------------------------------------------------
;;  Check if minimum energy > 1 keV
mn_avg_E       = MIN(avg_ener_out,/NAN)
test           = (mn_avg_E[0] GT 1e3)
IF (test[0]) THEN lab_suffx = ' keV' ELSE lab_suffx = ' eV'
IF (test[0]) THEN lab_fac   = 1d-3   ELSE lab_fac   = 1d0
avg_en_lab     = avg_ener_out*lab_fac[0]
ener_cols      = LONARR(n_e_out[0])
ener_labs      = STRARR(n_e_out[0])
;;  Check if any entire energy bin is full of NaNs or 0's
test           = TOTAL(FINITE(pad_ener),1L,/NAN) EQ 0
bad            = WHERE(test,bd,COMPLEMENT=good,NCOMPLEMENT=gd)
test           = (gd[0] GT 0) AND (bd[0] GT 0L)
IF (test[0]) THEN BEGIN
  ;;  Remove bad energies
  avg_en_lab[bad]   = f
  ener_labs[good]   = STRTRIM(ROUND(avg_en_lab[good]),2L)+lab_suffx[0]
  ener_cols[good]   = LINDGEN(gd[0])*(250L - 30L)/(gd[0] - 1L) + 30L
  ;;  Want lowest(highest) energy = Red(Purple)
  ;;    --> Reverse order of colors if E[0] < E[1]
  diff              = MAX(avg_en_lab[good],lx,/NAN) - MIN(avg_en_lab[good],ln,/NAN)
  IF (lx[0] GT ln[0]) THEN ener_cols = REVERSE(ener_cols)
ENDIF ELSE BEGIN
  IF (gd[0] GT 0) THEN BEGIN
    ener_labs         = STRTRIM(ROUND(avg_en_lab),2L)+lab_suffx[0]
    ener_cols         = LINDGEN(n_e_out[0])*(250L - 30L)/(n_e_out[0] - 1L) + 30L
    ;;  Want lowest(highest) energy = Red(Purple)
    ;;    --> Reverse order of colors if E[0] < E[1]
    diff              = MAX(avg_en_lab,lx,/NAN) - MIN(avg_en_lab,ln,/NAN)
    IF (lx[0] GT ln[0]) THEN ener_cols = REVERSE(ener_cols)
  ENDIF
ENDELSE
;;----------------------------------------------------------------------------------------
;;  Estimate YRANGE for TPLOT
;;----------------------------------------------------------------------------------------
temp           = REFORM(pad_data,n_dat[0]*n_e_out[0]*n_pa[0])
yran0          = calc_log_scale_yrange(temp)
test           = (N_ELEMENTS(yran0) EQ 2)
IF (test[0]) THEN IF (yran0[0] NE yran0[1]) THEN yran = yran0
;;----------------------------------------------------------------------------------------
;;  Define return structures
;;----------------------------------------------------------------------------------------
data_str       = {X:pad_time,Y:pad_data,V1:pad_ener,V2:pad_pang}
opts_str       = {PANEL_SIZE:2.,YSTYLE:1,XMINOR:5,XTICKLEN:0.04,YTICKLEN:0.01}
IF (N_ELEMENTS(yran) EQ 2) THEN BEGIN
  dopts_str      = {YLOG:1,LABELS:ener_labs,COLORS:ener_cols,YRANGE:yran,SPEC:0,YMINOR:9L}
ENDIF ELSE BEGIN
  dopts_str      = {YLOG:1,LABELS:ener_labs,COLORS:ener_cols,SPEC:0,YMINOR:9L}
ENDELSE
;;  Add LIMITS info if applicable
IF (SIZE(limits,/TYPE) EQ 8) THEN BEGIN
  extract_tags,dlim,dopts_str                      ;;  Get current default plot limits settings
  extract_tags,dlim,limits,/PLOT                   ;;  Get plot limits settings from LIMITS, if present
  dlim_tags = TAG_NAMES(dlim)
  extract_tags,lim,opts_str,EXCEPT_TAGS=dlim_tags  ;;  Try to avoid overlapping tags
ENDIF ELSE BEGIN
  dlim      = dopts_str
  lim       = opts_str
ENDELSE
struct         = {DATA:data_str,DLIMITS:dlim,LIMITS:lim,UNITS:gunits[0],BINS:bins,$
                  E_UNITS:lab_suffx[0],FRAME_SUFFX:f_suffx[0]}
;;----------------------------------------------------------------------------------------
;;  Return to user
;;----------------------------------------------------------------------------------------

RETURN,struct
END


;+
;*****************************************************************************************
;
;  PROCEDURE:   temp_create_stacked_pad_spec_2_tplot.pro
;  PURPOSE  :   This routine calculates a pitch-angle distribution (PAD) energy spectra
;                 from an input array of 3D particle velocity distributions and sends
;                 the results to TPLOT.  The results are very similar to those returned
;                 by get_padspecs.pro.
;
;  CALLED BY:   
;               NA
;
;  INCLUDES:
;               temp_calc_pad_spect.pro
;
;  CALLS:
;               test_wind_vs_themis_esa_struct.pro
;               dat_3dp_str_names.pro
;               dat_themis_esa_str_names.pro
;               temp_calc_pad_spect.pro
;               wind_3dp_units.pro
;               str_element.pro
;               store_data.pro
;
;  REQUIRES:    
;               1)  UMN Modified Wind/3DP IDL Libraries
;
;  INPUT:
;               DAT         :  [N]-Element [structure] array of THEMIS ESA or Wind/3DP
;                                IDL data structures containing the 3D velocity
;                                distribution functions to use to create the stacked
;                                PAD energy spectra plots
;
;  EXAMPLES:    
;               temp_create_stacked_pad_spec_2_tplot,dat,LIMITS=limits,UNITS=units,    $
;                                                    BINS=bins,NAME=name,TRANGE=trange,$
;                                                    ERANGE=erange,NUM_PA=num_pa,      $
;                                                    NO_TRANS=no_trans
;
;  KEYWORDS:    
;               **********************************
;               ***       DIRECT  INPUTS       ***
;               **********************************
;               LIMITS      :  Scalar [structure] that may contain any combination of the
;                                following structure tags or keywords accepted by
;                                PLOT.PRO:
;                                  XLOG,   YLOG,   ZLOG,
;                                  XRANGE, YRANGE, ZRANGE,
;                                  XTITLE, YTITLE,
;                                  TITLE, POSITION, REGION, etc.
;                                  (see IDL documentation for a description)
;               UNITS       :  Scalar [string] defining the units to use for the
;                                vertical axis of the plot and the outputs YDAT and DYDAT
;                                [Default = 'flux' or number flux]
;               BINS        :  [N]-Element [byte] array defining which solid angle bins
;                                should be plotted [i.e., BINS[good] = 1b] and which
;                                bins should not be plotted [i.e., BINS[bad] = 0b].
;                                One can also define bins as an array of indices that
;                                define which solid angle bins to plot.  If this is the
;                                case, then on output, BINS will be redefined to an
;                                array of byte values specifying which bins are TRUE or
;                                FALSE.
;                                [Default:  BINS[*] = 1b]
;               NAME        :  Scalar [string] defining the TPLOT handle for the energy
;                                omni-directional spectra
;                                [Default : '??_ener_spec', ?? = 'el','eh','elb',etc.]
;               TRANGE      :  [2]-Element [double] array of Unix times specifying the
;                                time range over which to calculate spectra
;                                [Default : [MIN(DAT.TIME),MAX(DAT.END_TIME)] ]
;               ERANGE      :  [2]-Element [double] array defining the energy [eV] range
;                                over which to calculate spectra
;                                [Default : [MIN(DAT.ENERGY),MAX(DAT.ENERGY)] ]
;               NUM_PA      :  Scalar [integer] that defines the number of pitch-angle
;                                bins to calculate for the resulting distribution
;                                [Default = 8]
;               NO_TRANS    :  If set, routine will not transform data into bulk flow
;                                rest frame defined by the structure tag VSW in each
;                                DAT structure (VELOCITY tag in THEMIS ESA structures
;                                will work as well so long as the THETA/PHI angles are
;                                in the same coordinate basis as VELOCITY and MAGF)
;                                [Default = FALSE]
;
;   CHANGED:  1)  Continued to write routine
;                                                                   [02/10/2015   v1.0.0]
;
;   NOTES:      
;               1)  See also:  get_spec.pro, get_padspecs.pro, and calc_padspecs.pro
;               
;
;  REFERENCES:  
;               1)  Carlson et al., (1983), "An instrument for rapidly measuring
;                      plasma distribution functions with high resolution,"
;                      Adv. Space Res. Vol. 2, pp. 67-70.
;               2)  Curtis et al., (1989), "On-board data analysis techniques for
;                      space plasma particle instruments," Rev. Sci. Inst. Vol. 60,
;                      pp. 372.
;               3)  Lin et al., (1995), "A Three-Dimensional Plasma and Energetic
;                      particle investigation for the Wind spacecraft," Space Sci. Rev.
;                      Vol. 71, pp. 125.
;               4)  Paschmann, G. and P.W. Daly (1998), "Analysis Methods for Multi-
;                      Spacecraft Data," ISSI Scientific Report, Noordwijk, 
;                      The Netherlands., Int. Space Sci. Inst.
;               5)  McFadden, J.P., C.W. Carlson, D. Larson, M. Ludlam, R. Abiad,
;                      B. Elliot, P. Turin, M. Marckwordt, and V. Angelopoulos
;                      "The THEMIS ESA Plasma Instrument and In-flight Calibration,"
;                      Space Sci. Rev. 141, pp. 277-302, (2008).
;               6)  McFadden, J.P., C.W. Carlson, D. Larson, J.W. Bonnell,
;                      F.S. Mozer, V. Angelopoulos, K.-H. Glassmeier, U. Auster
;                      "THEMIS ESA First Science Results and Performance Issues,"
;                      Space Sci. Rev. 141, pp. 477-508, (2008).
;               7)  Auster, H.U., K.-H. Glassmeier, W. Magnes, O. Aydogar, W. Baumjohann,
;                      D. Constantinescu, D. Fischer, K.H. Fornacon, E. Georgescu,
;                      P. Harvey, O. Hillenmaier, R. Kroth, M. Ludlam, Y. Narita,
;                      R. Nakamura, K. Okrafka, F. Plaschke, I. Richter, H. Schwarzl,
;                      B. Stoll, A. Valavanoglou, and M. Wiedemann "The THEMIS Fluxgate
;                      Magnetometer," Space Sci. Rev. 141, pp. 235-264, (2008).
;               8)  Angelopoulos, V. "The THEMIS Mission," Space Sci. Rev. 141,
;                      pp. 5-34, (2008).
;
;   CREATED:  02/06/2015
;   CREATED BY:  Lynn B. Wilson III
;    LAST MODIFIED:  02/10/2015   v1.0.0
;    MODIFIED BY: Lynn B. Wilson III
;
;*****************************************************************************************
;-

PRO temp_create_stacked_pad_spec_2_tplot,dat,LIMITS=limits,UNITS=units,BINS=bins,$
                                         NAME=name,TRANGE=trange,ERANGE=erange,  $
                                         NUM_PA=num_pa,NO_TRANS=no_trans

;;  Let IDL know that the following are functions
FORWARD_FUNCTION test_wind_vs_themis_esa_struct, dat_3dp_str_names,                 $
                 dat_themis_esa_str_names, temp_calc_pad_spect, wind_3dp_units
;;****************************************************************************************
ex_start = SYSTIME(1)
;;****************************************************************************************
;;----------------------------------------------------------------------------------------
;;  Define some constants and dummy variables
;;----------------------------------------------------------------------------------------
f              = !VALUES.F_NAN
d              = !VALUES.D_NAN
mission_logic  = [0b,0b]                ;;  Logic variable used for determining which mission is associated with DAT
def_nm_suffx   = '_pad_spec'
;;  Dummy error messages
noinpt_msg     = 'User must supply an array of velocity distribution functions as IDL structures...'
notstr_msg     = 'DAT must be an array of IDL structures...'
notvdf_msg     = 'Input must be a velocity distribution function as an IDL structure...'
badtra_msg     = 'TRANGE must be a 2-element array of Unix times and DAT must have a range of times as well...'
badera_msg     = 'ERANGE must be a 2-element array of energies [eV] and DAT.ENERGY must have a range of energies as well...'
;;----------------------------------------------------------------------------------------
;;  Check input
;;----------------------------------------------------------------------------------------
IF (N_PARAMS() LT 1) THEN BEGIN
  MESSAGE,noinpt_msg,/INFORMATIONAL,/CONTINUE
  RETURN
ENDIF
IF (SIZE(dat,/TYPE) NE 8L OR N_ELEMENTS(dat) LT 2) THEN BEGIN
  MESSAGE,notstr_msg,/INFORMATIONAL,/CONTINUE
  RETURN
ENDIF
;;  Check to make sure distribution has the correct format
test0          = test_wind_vs_themis_esa_struct(dat[0],/NOM)
test           = (test0.(0) + test0.(1)) NE 1
IF (test[0]) THEN BEGIN
  MESSAGE,notvdf_msg,/INFORMATIONAL,/CONTINUE
  RETURN
ENDIF
;;  Determine instrument (i.e., ESA or 3DP) and define electric charge
dat0           = dat[0]
IF (test0.(0)) THEN BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Wind
  ;;--------------------------------------------------------------------------------------
  mission      = 'Wind'
  strns        = dat_3dp_str_names(dat0[0])
  IF (SIZE(strns,/TYPE) NE 8) THEN BEGIN
    ;;  Neither Wind/3DP nor THEMIS/ESA VDF
    MESSAGE,not3dp_msg[0],/INFORMATIONAL,/CONTINUE
    RETURN
  ENDIF
  inst_nm_mode = strns.LC[0]         ;;  e.g., 'Pesa Low Burst'
ENDIF ELSE BEGIN
  IF (test0.(1)) THEN BEGIN
    ;;------------------------------------------------------------------------------------
    ;;  THEMIS
    ;;------------------------------------------------------------------------------------
    mission      = 'THEMIS'
    strns        = dat_themis_esa_str_names(dat0[0])
    IF (SIZE(strns,/TYPE) NE 8) THEN BEGIN
      ;;  Neither Wind/3DP nor THEMIS/ESA VDF
      MESSAGE,notthm_msg[0],/INFORMATIONAL,/CONTINUE
      RETURN
    ENDIF
    temp         = strns.LC[0]                  ;;  e.g., 'IESA 3D Reduced Distribution'
    tposi        = STRPOS(temp[0],'Distribution') - 1L
    inst_nm_mode = STRMID(temp[0],0L,tposi[0])  ;;  e.g., 'IESA 3D Reduced'
  ENDIF ELSE BEGIN
    ;;------------------------------------------------------------------------------------
    ;;  Other mission?
    ;;------------------------------------------------------------------------------------
    ;;  Not handling any other missions yet
    MESSAGE,badvdf_msg[0],/INFORMATIONAL,/CONTINUE
    RETURN
  ENDELSE
ENDELSE
mission_logic  = [(test0.(0))[0],(test0.(1))[0]]
data_str       = strns.SN[0]     ;;  e.g., 'el' for Wind EESA Low or 'peeb' for THEMIS EESA
;;----------------------------------------------------------------------------------------
;;  Define parameters relevant to structure format
;;----------------------------------------------------------------------------------------
n_dat          = N_ELEMENTS(dat)        ;;  # of data structures
n_b            = dat[0].NBINS[0]        ;;  # of solid angle bins per structure
n_e            = dat[0].NENERGY[0]      ;;  # of energy bins per structure
;;----------------------------------------------------------------------------------------
;;  Check keywords
;;----------------------------------------------------------------------------------------
;;  Check NAME
test           = (N_ELEMENTS(name) EQ 0) OR (SIZE(name,/TYPE) NE 7)
IF (test[0]) THEN name = data_str[0]+def_nm_suffx[0]
;;----------------------------------------------------------------------------------------
;;  Calculate pitch-angle distributin (PAD) spectra
;;----------------------------------------------------------------------------------------
spec_struc     = temp_calc_pad_spect(dat,UNITS=units,BINS=bins,TRANGE=trange,       $
                                     ERANGE=erange,NUM_PA=num_pa,NO_TRANS=no_trans, $
                                     LIMITS=limits)
IF (SIZE(spec_struc,/TYPE) NE 8) THEN STOP     ;;  Debug
;;  Define variables for output
data0          = spec_struc.DATA
dlim           = spec_struc.DLIMITS
lim            = spec_struc.LIMITS
;;  Define frame of reference suffix
f_suffx        = spec_struc.FRAME_SUFFX
;;  Define units for TPLOT handle and YSUBTITLE
gunits         = spec_struc.UNITS
temp           = wind_3dp_units(gunits)
gunits         = temp.G_UNIT_NAME      ;;  e.g. 'flux'
punits         = temp.G_UNIT_P_NAME    ;;  e.g. ' (# cm!U-2!Ns!U-1!Nsr!U-1!NeV!U-1!N)'
;;  Define YTITLE and YSUBTITLE
ytitle         = data_str[0]+' '+gunits[0]
ysubtl         = STRMID(punits[0],1L)  ;;  e.g. '(# cm!U-2!Ns!U-1!Nsr!U-1!NeV!U-1!N)'
str_element,dlim,   'YTITLE',ytitle[0],/ADD_REPLACE
str_element,dlim,'YSUBTITLE',ysubtl[0],/ADD_REPLACE
out_name       = name[0]+'_'+f_suffx[0]+'_'+gunits[0]  ;;  e.g., 'elspec_swf_raw_flux'
str_element,dlim,'LABFLAG',1,/ADD_REPLACE
;;----------------------------------------------------------------------------------------
;;  Send results to TPLOT
;;----------------------------------------------------------------------------------------
store_data,out_name[0],DATA=data0,DLIM=dlim,LIM=lim
;;----------------------------------------------------------------------------------------
;;  Separate PADs and send results to TPLOT
;;----------------------------------------------------------------------------------------
n_pa           = N_ELEMENTS(data0.V2[0,*])    ;;  # of PAs
;;  Determine the energy units
;;    0 =  eV  [Default]
;;    1 = keV
;;    2 = MeV
test           = (STRTRIM(STRLOWCASE(spec_struc.E_UNITS),2L) EQ ['','k','m']+'ev')
e_units        = ((WHERE(test))[0] > 0) < 2
newna          = out_name[0]
ang            = FLTARR(2,n_pa[0] - 1L)
FOR i=0L, n_pa[0] - 2L DO BEGIN
  j        = i[0] + 1L
  pang     = FLTARR(2)
  reduce_pads,newna[0],2L,i[0],j[0],ANGLES=pang,/NAN
  ang[*,i] = pang
ENDFOR
;;----------------------------------------------------------------------------------------
;;  Fix TPLOT options
;;----------------------------------------------------------------------------------------
;;  Fix colors and energy bin labels
new_tpn        = tnames(newna[0]+'-2-*')
options,new_tpn,'COLORS'
options,new_tpn,'LABELS'
options,new_tpn,'COLORS',dlim.COLORS,/DEF
options,new_tpn,'LABELS',dlim.LABELS,/DEF
;;  Fix YRANGE, YMINOR, and YSTYLE
str_element,dlim,   'YRANGE',yran00
options,new_tpn,'YRANGE'
options,new_tpn,'YMINOR'
options,new_tpn,'YSTYLE'
test           = (N_ELEMENTS(yran00) EQ 2)
IF (test[0]) THEN yran11 = yran00 ELSE yran11 = [0,0]
test           = (yran11[0] NE yran11[1])
IF (test[0]) THEN options,new_tpn,'YRANGE',yran11,/DEF
options,new_tpn,'YMINOR',9L,/DEF
options,new_tpn,'YSTYLE',1,/DEF
;;  Fix YTITLEs
FOR i=0L, N_ELEMENTS(new_tpn) - 1L DO BEGIN
  get_data,new_tpn[i],DATA=temp00,DLIM=dlim00,LIM=lim00
  str_element,dlim00,   'YTITLE',yttl00
  new_yttl = ytitle[0]+' ['+yttl00[0]+']'
  str_element,dlim00,   'YTITLE',new_yttl[0],/ADD_REPLACE
  str_element,dlim00,'YSUBTITLE',  ysubtl[0],/ADD_REPLACE
  ;;  Send back to TPLOT
  store_data,new_tpn[i],DATA=temp00,DLIM=dlim00,LIM=lim00
ENDFOR
;;----------------------------------------------------------------------------------------
;;  Return to user
;;----------------------------------------------------------------------------------------
;;****************************************************************************************
ex_time = SYSTIME(1) - ex_start
MESSAGE,STRING(ex_time)+' seconds execution time.',/cont,/info
;;****************************************************************************************

RETURN
END

